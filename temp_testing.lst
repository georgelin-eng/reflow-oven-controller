0000              1   ; 76E003 ADC test program: Reads channel 7 on P1.1, pin 14
0000              2   ; This version uses an LED as voltage reference connected to pin 6 (P1.7/AIN0)
0000              3   
                  5   $LIST
0000              7   
0000              8   ;  N76E003 pinout:
0000              9   ;                               -------
0000             10   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             11   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             12   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             13   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             14   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             15   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             16   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             17   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             18   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             19   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             20   ;                               -------
0000             21   ;
0000             22   
0000             23   CLK               EQU 16600000 ; Microcontroller system frequency in Hz
0000             24   BAUD              EQU 115200 ; Baud rate of UART in bps
0000             25   TIMER1_RELOAD     EQU (0x100-(CLK/(16*BAUD)))
0000             26   TIMER0_RELOAD_1MS EQU (0x10000-(CLK/1000))
0000             27   
0000             28   ORG 0x0000
0000 0204CB      29   ljmp main
0003             30   
0003             31   ;                     1234567890123456    <- This helps determine the location of the counter
0003 2A2A2A20    32   test_message:     db '*** ADC TEST ***', 0
     41444320
     54455354
     202A2A2A
     00
0014 56287069    33   value_message:    db 'V(pin 14)=      ', 0
     6E203134
     293D2020
     20202020
     00
0025             34   cseg
0025             35   ; These 'equ' must match the hardware wiring
0025             36   LCD_RS equ P1.3
0025             37   LCD_E  equ P1.4
0025             38   LCD_D4 equ P0.0
0025             39   LCD_D5 equ P0.1
0025             40   LCD_D6 equ P0.2
0025             41   LCD_D7 equ P0.3
0025             42   
                 44   	$LIST
00D9             46   
00D9             47   ; These register definitions needed by 'math32.inc'
0030             48   DSEG at 30H
0030             49   x:   ds 4
0034             50   y:   ds 4
0038             51   bcd: ds 5
003D             52   VLED_ADC: ds 2
003F             53   
0000             54   BSEG
0000             55   mf: dbit 1
0001             56   
                547   $LIST
                 58   $LIST
0349             60   
0349             61   
0349             62   Init_All:
0349             63   ; Configure all the pins for biderectional I/O
0349 75AC00      64   mov P3M1, #0x00
034C 75AD00      65   mov P3M2, #0x00
034F 75B300      66   mov P1M1, #0x00
0352 75B400      67   mov P1M2, #0x00
0355 75B100      68   mov P0M1, #0x00
0358 75B200      69   mov P0M2, #0x00
035B             70   
035B 438E10      71   orl CKCON, #0x10 ; CLK is the input for timer 1
035E 438780      72   orl PCON, #0x80 ; Bit SMOD=1, double baud rate
0361 759852      73   mov SCON, #0x52
0364 53C4DF      74   anl T3CON, #0b11011111
0367 53890F      75   anl TMOD, #0x0F ; Clear the configuration bits for timer 1
036A 438920      76   orl TMOD, #0x20 ; Timer 1 Mode 2
036D 758DF7      77   mov TH1, #TIMER1_RELOAD ; TH1=TIMER1_RELOAD;
0370 D28E        78   setb TR1
0372             79   
0372             80   ; Using timer 0 for delay functions.  Initialize here:
0372 C28C        81   clr TR0 ; Stop timer 0
0374 438E08      82   orl CKCON,#0x08 ; CLK is the input for timer 0
0377 5389F0      83   anl TMOD,#0xF0 ; Clear the configuration bits for timer 0
037A 438901      84   orl TMOD,#0x01 ; Timer 0 in Mode 1: 16-bit timer
037D             85   
037D             86   ; Initialize the pins used by the ADC (P1.1, P1.7) as input.
037D 43B382      87   orl P1M1, #0b10000010
0380 53B47D      88   anl P1M2, #0b01111101
0383             89   
0383             90   ; Initialize and start the ADC:
0383 53E8F0      91   anl ADCCON0, #0xF0
0386 43E807      92   orl ADCCON0, #0x07 ; Select channel 7
0389             93   ; AINDIDS select if some pins are analog inputs or digital I/O:
0389 75F600      94   mov AINDIDS, #0x00 ; Disable all analog inputs
038C 43F681      95   orl AINDIDS, #0b10000001 ; Activate AIN0 and AIN7 analog inputs
038F 43E101      96   orl ADCCON1, #0x01 ; Enable ADC
0392             97   
0392 22          98   ret
0393             99   
0393            100   InitSerialPort:
0393            101   
0393            102       ; Since the reset button bounces, we need to wait a bit before
0393            103       ; sending messages, otherwise we risk displaying gibberish!
0393 79C8       104       mov R1, #200
0395 7868       105       mov R0, #104
0397 D8FE       106       djnz R0, $   ; 4 cycles->4*60.285ns*104=25us
0399 D9FA       107       djnz R1, $-4 ; 25us*200=5.0ms
039B            108   
039B            109       ; Now we can proceed with the configuration of the serial port
039B 438E10     110   orl CKCON, #0x10 ; CLK is the input for timer 1
039E 438780     111   orl PCON, #0x80 ; Bit SMOD=1, double baud rate
03A1 759852     112   mov SCON, #0x52
03A4 53C4DF     113   anl T3CON, #0b11011111
03A7 53890F     114   anl TMOD, #0x0F ; Clear the configuration bits for timer 1
03AA 438920     115   orl TMOD, #0x20 ; Timer 1 Mode 2
03AD 758DF7     116   mov TH1, #TIMER1_RELOAD
03B0 D28E       117   setb TR1
03B2 22         118       ret
03B3            119   
03B3            120   ; Send a character using the serial port
03B3            121   putchar:
03B3 3099FD     122       jnb TI, putchar
03B6 C299       123       clr TI
03B8 F599       124       mov SBUF, a
03BA 22         125       ret
03BB            126   
03BB            127   ;send a BCD num to PuTTy
03BB            128   
                129   Send_BCD mac
                130   push ar0
                131   mov r0, %0
                132   lcall ?Send_BCD
                133   pop ar0
                134   endmac
03BB            135   
03BB            136   ?Send_BCD:
03BB C0E0       137   push acc
03BD            138   ;write most significant digit
03BD E8         139   mov a, r0
03BE C4         140   swap a
03BF 540F       141   anl a, #0fh
03C1 4430       142   orl a, #30h
03C3 1203B3     143   lcall putchar
03C6            144   ;write least significant digit
03C6 E8         145   mov a, r0
03C7 540F       146   anl a, #0fh
03C9 4430       147   orl a, #30h
03CB 1203B3     148   lcall putchar
03CE D0E0       149   pop acc
03D0 22         150   ret
03D1            151   
03D1            152   
03D1            153   Send_formated_BCD_nocrnl:
03D1            154   
03D1 C000       155   push ar0
03D3 A83B       155   mov r0, bcd+3
03D5 1203BB     155   lcall ?Send_BCD
03D8 D000       155   pop ar0
03DA            155   
03DA C000       156   push ar0
03DC A83A       156   mov r0, bcd+2
03DE 1203BB     156   lcall ?Send_BCD
03E1 D000       156   pop ar0
03E3 742E       157   mov a, #46
03E5 1203B3     158   lcall putchar
03E8 C000       159   push ar0
03EA A839       159   mov r0, bcd+1
03EC 1203BB     159   lcall ?Send_BCD
03EF D000       159   pop ar0
03F1 C000       160   push ar0
03F3 A838       160   mov r0, bcd+0
03F5 1203BB     160   lcall ?Send_BCD
03F8 D000       160   pop ar0
03FA 22         161   ret
03FB            162   
03FB            163   
03FB            164   Send_formated_BCD:
03FB            165   
03FB C000       166   push ar0
03FD A83B       166   mov r0, bcd+3
03FF 1203BB     166   lcall ?Send_BCD
0402 D000       166   pop ar0
0404 C000       167   push ar0
0406 A83A       167   mov r0, bcd+2
0408 1203BB     167   lcall ?Send_BCD
040B D000       167   pop ar0
040D 742E       168   mov a, #46
040F 1203B3     169   lcall putchar
0412 C000       170   push ar0
0414 A839       170   mov r0, bcd+1
0416 1203BB     170   lcall ?Send_BCD
0419 D000       170   pop ar0
041B C000       171   push ar0
041D A838       171   mov r0, bcd+0
041F 1203BB     171   lcall ?Send_BCD
0422 D000       171   pop ar0
0424 1204BF     172   lcall putCR_NL
0427 22         173   ret
0428            174   ; Send a constant-zero-terminated string using the serial port
0428            175   SendString:
0428 E4         176       clr A
0429 93         177       movc A, @A+DPTR
042A 6006       178       jz SendStringDone
042C 1203B3     179       lcall putchar
042F A3         180       inc DPTR
0430 80F6       181       sjmp SendString
0432            182      
0432            183   SendStringDone:
0432 22         184       ret
0433            185    
0433            186   Hello_World:
0433 48656C6C   187       DB  'Hello, World!', '\r', '\n', 0
     6F2C2057
     6F726C64
     210D0A00
0443            188          
0443            189   wait_1ms:
0443 C28C       190   clr TR0 ; Stop timer 0
0445 C28D       191   clr TF0 ; Clear overflow flag
0447 758CBF     192   mov TH0, #high(TIMER0_RELOAD_1MS)
044A 758A28     193   mov TL0,#low(TIMER0_RELOAD_1MS)
044D D28C       194   setb TR0
044F 308DFD     195   jnb TF0, $ ; Wait for overflow
0452 22         196   ret
0453            197   
0453            198   ; Wait the number of miliseconds in R2
0453            199   waitms:
0453 120443     200   lcall wait_1ms
0456 DAFB       201   djnz R2, waitms
0458 22         202   ret
0459            203   
0459            204   ; We can display a number any way we want.  In this case with
0459            205   ; four decimal places.
0459            206   Display_formated_BCD:
0459 C0E0       207            push acc
045B 7408       207            mov a, #8
045D 14         207            dec a
045E 1200BC     207            lcall ?Set_Cursor_2 ; Select column and row
0461 D0E0       207            pop acc
0463 C000       208            push ar0
0465 A83B       208            mov r0, bcd+3
0467 1200C3     208            lcall ?Display_BCD
046A D000       208            pop ar0
046C C000       209            push ar0
046E A83A       209            mov r0, bcd+2
0470 1200C3     209            lcall ?Display_BCD
0473 D000       209            pop ar0
0475 C0E0       210            push acc
0477 742E       210            mov a, #'.'
0479 120074     210            lcall ?WriteData
047C D0E0       210            pop acc
047E C000       211            push ar0
0480 A839       211            mov r0, bcd+1
0482 1200C3     211            lcall ?Display_BCD
0485 D000       211            pop ar0
0487 C000       212            push ar0
0489 A838       212            mov r0, bcd+0
048B 1200C3     212            lcall ?Display_BCD
048E D000       212            pop ar0
0490            213   ;Set_Cursor(2, 10)
0490            214   ;Display_char(#'=')
0490 22         215   ret
0491            216   
0491            217   
0491            218   Read_ADC:
0491 C2EF       219   clr ADCF
0493 D2EE       220   setb ADCS ;  ADC start trigger signal
0495 30EFFD     221       jnb ADCF, $ ; Wait for conversion complete
0498            222      
0498            223       ; Read the ADC result and store in [R1, R0]
0498 E5C2       224       mov a, ADCRL
049A 540F       225       anl a, #0x0f
049C F8         226       mov R0, a
049D E5C3       227       mov a, ADCRH  
049F C4         228       swap a
04A0 C0E0       229       push acc
04A2 540F       230       anl a, #0x0f
04A4 F9         231       mov R1, a
04A5 D0E0       232       pop acc
04A7 54F0       233       anl a, #0xf0
04A9 48         234       orl a, R0
04AA F8         235       mov R0, A
04AB 22         236   ret
04AC            237   
04AC            238   putNum:
04AC E4         239   clr a
04AD E9         240   mov a, r1
04AE 75F00A     241   mov b, #10
04B1 84         242   div ab
04B2 2430       243   add a, #48
04B4 1203B3     244   lcall putchar
04B7            245   
04B7 E5F0       246   mov a, b
04B9 2430       247   add a, #48
04BB 1203B3     248   lcall putchar
04BE 22         249   ret
04BF            250   
04BF            251   
04BF            252   putCR_NL: ;function to print Carriage return and NL
04BF E4         253   clr a
04C0 740D       254   mov a, #13
04C2 1203B3     255   lcall putchar
04C5 740A       256   mov a, #10
04C7 1203B3     257   lcall putchar
04CA 22         258   ret
04CB            259   
04CB            260   main:
04CB 75817F     261   mov sp, #0x7f
04CE 120349     262   lcall Init_All
04D1 12007E     263       lcall LCD_4BIT
04D4            264       ;now inserting the serial initialization
04D4            265      
04D4 120393     266       lcall InitSerialPort
04D7 900433     267       mov DPTR, #Hello_World
04DA 120428     268       lcall SendString
04DD            269      
04DD            270      
04DD            271       ; initial messages in LCD
04DD C0E0       272            push acc
04DF 7401       272            mov a, #1
04E1 14         272            dec a
04E2 1200BE     272            lcall ?Set_Cursor_1 ; Select column and row
04E5 D0E0       272            pop acc
04E7            273       ;Send_Constant_String(#test_message)
04E7 C0E0       274            push acc
04E9 7401       274            mov a, #1
04EB 14         274            dec a
04EC 1200BC     274            lcall ?Set_Cursor_2 ; Select column and row
04EF D0E0       274            pop acc
04F1            275       ;Send_Constant_String(#value_message)
04F1            276      
04F1            277   Forever:
04F1            278   
04F1            279   ; Read the 2.08V LED voltage connected to AIN0 on pin 6
04F1 53E8F0     280   anl ADCCON0, #0xF0
04F4 43E800     281   orl ADCCON0, #0x00 ; Select channel 0
04F7            282   
04F7 120491     283   lcall Read_ADC
04FA            284   ; Save result for later use
04FA 883D       285   mov VLED_ADC+0, R0
04FC 893E       286   mov VLED_ADC+1, R1
04FE            287   
04FE            288   ; Read the signal connected to AIN7
04FE 53E8F0     289   anl ADCCON0, #0xF0
0501 43E807     290   orl ADCCON0, #0x07 ; Select channel 7
0504 120491     291   lcall Read_ADC
0507            292      
0507            293   ; Convert to voltage
0507 8830       294   mov x+0, R0
0509 8931       295   mov x+1, R1
050B            296   ; Pad other bits with zero
050B 753200     297   mov x+2, #0
050E 753300     298   mov x+3, #0
0511 7534CE     299            mov y+0, #low (20430 % 0x10000) 
0514 75354F     299            mov y+1, #high(20430 % 0x10000) 
0517 753600     299            mov y+2, #low (20430 / 0x10000) 
051A 753700     299            mov y+3, #high(20430 / 0x10000)  ; The MEASURED LED voltage: 2.074V, with 4 decimal places
051D 120253     300   lcall mul32
0520            301   ; Retrive the ADC LED value
0520 853D34     302   mov y+0, VLED_ADC+0
0523 853E35     303   mov y+1, VLED_ADC+1
0526            304   ; Pad other bits with zero
0526 753600     305   mov y+2, #0
0529 753700     306   mov y+3, #0
052C 1202E0     307   lcall div32
052F            308   
052F            309   
052F            310   
052F 753423     311            mov y+0, #low (803 % 0x10000) 
0532 753503     311            mov y+1, #high(803 % 0x10000) 
0535 753600     311            mov y+2, #low (803 / 0x10000) 
0538 753700     311            mov y+3, #high(803 / 0x10000) ;multiplying V pin by 80.3153
053B 120253     312   lcall mul32
053E            313   
053E 753460     314            mov y+0, #low (220000 % 0x10000) 
0541 75355B     314            mov y+1, #high(220000 % 0x10000) 
0544 753603     314            mov y+2, #low (220000 / 0x10000) 
0547 753700     314            mov y+3, #high(220000 / 0x10000)  ;adding 22, will change to ambient later
054A 12019E     315   lcall add32
054D            316   
054D            317   ;use put char to put individual characters
054D            318   ; Convert to BCD and display
054D 1200D9     319   lcall hex2bcd
0550            320   
0550 120459     321   lcall Display_formated_BCD
0553 1203D1     322   lcall Send_formated_BCD_nocrnl
0556            323   
0556 7534A9     324            mov y+0, #low (27305 % 0x10000) 
0559 75356A     324            mov y+1, #high(27305 % 0x10000) 
055C 753600     324            mov y+2, #low (27305 / 0x10000) 
055F 753700     324            mov y+3, #high(27305 / 0x10000) 
0562 1201BF     325   lcall sub32
0565 1200D9     326   lcall hex2bcd
0568            327   
0568            328   
0568 53E8F0     329   anl ADCCON0, #0xF0
056B 43E801     330   orl ADCCON0, #0x01 ; Select channel 7
056E 120491     331   lcall Read_ADC
0571            332   
0571 8830       333   mov x+0, R0
0573 8931       334   mov x+1, R1
0575            335   ; Pad other bits with zero
0575 753200     336   mov x+2, #0
0578 753300     337   mov x+3, #0
057B 7534CE     338            mov y+0, #low (20430 % 0x10000) 
057E 75354F     338            mov y+1, #high(20430 % 0x10000) 
0581 753600     338            mov y+2, #low (20430 / 0x10000) 
0584 753700     338            mov y+3, #high(20430 / 0x10000)  ; The MEASURED LED voltage: 2.074V, with 4 decimal places
0587 120253     339   lcall mul32
058A            340   ; Retrive the ADC LED value
058A 853D34     341   mov y+0, VLED_ADC+0
058D 853E35     342   mov y+1, VLED_ADC+1
0590            343   ; Pad other bits with zero
0590 753600     344   mov y+2, #0
0593 753700     345   mov y+3, #0
0596 1202E0     346   lcall div32
0599            347   
0599 1200D9     348   lcall hex2bcd
059C            349   
059C 1203FB     350   lcall Send_formated_BCD
059F            351   
059F            352   
059F            353   
059F 7AFA       354   mov R2, #250
05A1 120453     355   lcall waitms
05A4 7AFA       356   mov R2, #250
05A6 120453     357   lcall waitms
05A9            358      
05A9            359   
05A9            360   ; Wait 500 ms between conversions
05A9 7AFA       361   mov R2, #250
05AB 120453     362   lcall waitms
05AE 7A32       363   mov R2, #50
05B0 120453     364   lcall waitms
05B3            365   
05B3 0204F1     366   ljmp Forever
05B6            367   END
