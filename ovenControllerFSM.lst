0000              1   ; Main file. FSM implementing the following sequence:
0000              2   ;       State 0: Power = 0% (default state)
0000              3   ;               if start = NO, self loop; if start = YES, next state
0000              4   ;       State 1: Power = 100%; Sec = 0
0000              5   ;               if temp <= 150, self loop; temp > 150, next
0000              6   ;       State 2: Power = 20%
0000              7   ;               if sec <= 60s, self loop; sec>60s, next
0000              8   ;       State 3: Power = 100%; Sec = 0
0000              9   ;               if temp <= 220, self loop; temp>220, next
0000             10   ;       State 4: Power = 20%
0000             11   ;               if sec <= 45s, self loop; sec >45, next
0000             12   ;       State 5: Power = 0%
0000             13   ;               if temp >=60, self loop; temp <60, next
0000             14   ;       return to state 0
0000             15   
0000             16   
0000             17   ; MACROS ;
                 18   CLJNE mac
                 19       cjne %0, %1, $+3+2 ; Jump if no equal 2 bytes ahead since sjmp is a 2 byte instruction  
                 20       sjmp $+2+3 ; Jump 3 bytes after this instruction as ljmp takes 3 bytes to encode
                 21       ljmp %2 ; ljmp can access any part of the code space
                 22   endmac
0000             23   
0000             24   ; check_Push_Button(variable_flag, dest_label)
0000             25   ; Params
0000             26   ; variable_flag - variable we are checking in place of the pin e.g. PB_START_PIN
0000             27   ; dest_label - where to jump if a push button is not pressed
                 28   check_Push_Button MAC ; new one with multiplexed buttons
                 29           setb PB_START_PIN
                 30           setb PB_CHANGE_MENU_PIN
                 31           setb PB_INC_TEMP_PIN
                 32           setb PB_INC_TIME_PIN
                 33           setb PB_STOP_PIN
                 34           
                 35           setb SHARED_PIN
                 36           ; check if any push buttons are pressed
                 37           clr START_PIN             
                 38           clr CHANGE_MENU_PIN       
                 39           clr INC_TEMP_PIN          
                 40           clr INC_TIME_PIN          
                 41           clr STOP_PIN
                 42   
                 43           ; debounce
                 44           jb SHARED_PIN, %1 ; use helper label to jump to the end
                 45           Wait_Milli_Seconds(#50)
                 46           jb SHARED_PIN, %1
                 47   
                 48           ; Set the LCD data pins to logic 1
                 49           setb START_PIN
                 50           setb CHANGE_MENU_PIN
                 51           setb INC_TEMP_PIN
                 52           setb INC_TIME_PIN
                 53           setb STOP_PIN
                 54   
                 55           ; check push buttons 1 by one
                 56           clr START_PIN
                 57           mov c, SHARED_PIN
                 58           mov PB_START_PIN, c
                 59           setb START_PIN
                 60   
                 61           clr CHANGE_MENU_PIN
                 62           mov c, SHARED_PIN
                 63           mov PB_CHANGE_MENU_PIN, c
                 64           setb CHANGE_MENU_PIN
                 65   
                 66           clr INC_TEMP_PIN
                 67           mov c, SHARED_PIN
                 68           mov PB_INC_TEMP_PIN, c
                 69           setb INC_TEMP_PIN
                 70   
                 71           clr INC_TIME_PIN
                 72           mov c, SHARED_PIN
                 73           mov PB_INC_TIME_PIN, c
                 74           setb INC_TIME_PIN
                 75   
                 76           clr STOP_PIN
                 77           mov c, SHARED_PIN
                 78           mov PB_STOP_PIN, c
                 79           setb STOP_PIN
                 80   
                 81           jb %0, %1 ; check that the variable flag is not 1, otherwise jmp
                 82   
                 83   ENDMAC
0000             84   
0000             85   ; temp_gt_threshold(threshold_temp, new_oven_state)
0000             86   ; assumes that x has current temp value
0000             87   ; new_oven_state is a constant
                 88   temp_gt_threshold MAC
                 89           load_y(%0 * 10000)
                 90   
                 91           lcall x_gt_y
                 92           jnb mf, $+3+3+3 ; jump past the jnb and mov instructions which are both 3 bytes
                 93           mov OVEN_STATE, %1 
                 94           mov seconds_elapsed, #0
                 95           ljmp oven_FSM_done
                 96   
                 97   ENDMAC
0000             98   
                 99   temp_lt_threshold MAC
                100           load_y(%0 * 10000)
                101   
                102           lcall x_lt_y
                103           jnb mf, $+3+3 ; jump past the jnb and mov instructions which are both 3 bytes
                104           mov OVEN_STATE, %1 
                105           ljmp oven_FSM_done
                106   
                107   ENDMAC
0000            108   
                110   $LIST
0000            112   
0000            113   ;  N76E003 pinout:
0000            114   ;                               -------
0000            115   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000            116   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000            117   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000            118   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000            119   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000            120   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000            121   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000            122   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000            123   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000            124   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000            125   ;                               -------
0000            126   
0000            127   
0000            128   
0000            129   ;-------------------------------------------------------------------------------------------------------------------------------------
0000            130   
0000            131   ;                                                              STYLE GUIDE
0000            132   
0000            133   ; End flag names with _FLAG
0000            134   ; Use all upper case for constants (anything defined in equ or pin definitions), as it makes it easier to read quickly
0000            135   ; Before any jump or logic block comment purpose and try to comment throughout - code should be self explanatory, comment "why" it was implemented this way
0000            136   ; Before any block of code also comment who wrote it 
0000            137   ; Aim for variable names with 8-20 characters
0000            138   
0000            139   ; --------------------------------------------------------------------------------------------------------------------------
0000            140   
0000            141   
0000            142   ; Timer constants
0000            143   CLK                   EQU 16600000 ; Microcontroller system frequency in Hz
0000            144   BAUD                  EQU 115200   ; Baud rate of UART in bps 
0000            145   TIMER1_RELOAD         EQU (0x100-(CLK/(16*BAUD))) ; Serial ISR
0000            146   TIMER2_RELOAD         EQU (65536-(CLK/1000))    ; 1ms Delay ISR
0000            147   TIMER0_RELOAD         EQU (0x10000-(CLK/4096))    ; Sound ISR For 2kHz square wave
0000            148   
0000            149   ; Pin definitions + Hardware Wiring 
0000            150   ; Layout
0000            151   ; {Start} {Stop} {Change Menu} {Inc Temp} {Inc Time}
0000            152   START_PIN             EQU P1.3 
0000            153   CHANGE_MENU_PIN       EQU P0.1 
0000            154   INC_TEMP_PIN          EQU P0.2  
0000            155   INC_TIME_PIN          EQU P0.3  
0000            156   STOP_PIN              EQU P0.0  
0000            157   SHARED_PIN            EQU P1.5 
0000            158   
0000            159   PWM_OUT               EQU P1.2 ; Pin 13
0000            160   
0000            161   
0000            162   ; Menu states
0000            163   MENU_STATE_SOAK       EQU 0
0000            164   MENU_STATE_REFLOW     EQU 1
0000            165   MENU_STATE_TEST       EQU 2
0000            166   
0000            167   ; oven states
0000            168   OVEN_STATE_PREHEAT    EQU 0
0000            169   OVEN_STATE_SOAK       EQU 1
0000            170   OVEN_STATE_RAMP2PEAK  EQU 2
0000            171   OVEN_STATE_REFLOW     EQU 3
0000            172   OVEN_STATE_COOLING    EQU 4
0000            173   OVEN_STATE_FINISHED   EQU 5
0000            174   
0000            175   ; things to keep track of
0000            176   COOLED_TEMP           EQU 50 ; once cooled to this temperature, the reflow is now "finished"
0000            177   COOLED_TEMP_LOAD_MATH EQU COOLED_TEMP*10000 ; use to load up the math
0000            178   FINISHED_SECONDS      EQU 5
0000            179   MAX_TIME              EQU 90
0000            180   MIN_TIME              EQU 5
0000            181   MAX_TEMP              EQU 250
0000            182   MIN_TEMP              EQU 100
0000            183   
0000            184   ; define vectors
0000            185   ORG 0x0000 ; Reset vector
0000 020C03     186           ljmp main_program
0003            187   ORG 0x0003 ; External interrupt 0 vector
0003 32         188           reti
000B            189   ORG 0x000B ; Timer/Counter 0 overflow interrupt vector
000B 020492     190            ljmp Timer0_ISR
0013            191   ORG 0x0013 ; External interrupt 1 vector
0013 32         192            reti
001B            193   ORG 0x001B ; Timer/Counter 1 overflow interrupt vector 
001B 32         194            reti
0023            195   ORG 0x0023 ; Serial port receive/transmit interrupt vector 
0023 32         196            reti
002B            197   ORG 0x002B ; Timer/Counter 2 overflow interrupt vector
002B 020493     198            ljmp Timer2_ISR
002E            199   
002E            200   
002E            201   ; register definitions previously needed by 'math32.inc' - currently commented out for future changes
0030            202   DSEG at 0x30
0030            203   x               : ds 4
0034            204   y               : ds 4
0038            205   bcd             : ds 5
003D            206   bcdf            : ds 5
0042            207   VLED_ADC        : ds 2
0044            208   
0044            209   OVEN_STATE      : ds 1 ; stores oven FSM state
0045            210   MENU_STATE      : ds 1 ; stores menu FSM state
0046            211   temp_soak       : ds 1 
0047            212   time_soak       : ds 1
0048            213   temp_refl       : ds 1
0049            214   time_refl       : ds 1
004A            215   ; pwm             : ds 1 ; controls output power to SSR
004A            216   ; pwm_counter     : ds 1 
004A            217   
004A            218   Count1ms        : ds 2 ; determines the number of 1ms increments that have passed 
004C            219   Count1ms_PWM    : ds 1
004D            220   seconds_elapsed  : ds 1
004E            221   exit_seconds    : ds 1 ; if we dont reach 50 c before 60 S terminate
004F            222   
004F            223   pwm_counter: ds 1 ; Free running counter 0, 1, 2, ..., 100, 0
0050            224   pwm: ds 1 ; pwm percentage
0051            225   
0051            226   
002E            227   CSEG ;starts the absolute segment from that address
002E            228   ; These 'EQU' must match the hardware wiring
002E            229   LCD_RS          EQU P1.3
002E            230   ;LCD_RW         EQU PX.X ; Not used in this code, connect the pin to GND
002E            231   LCD_E           EQU P1.4
002E            232   LCD_D4          EQU P0.0
002E            233   LCD_D5          EQU P0.1
002E            234   LCD_D6          EQU P0.2
002E            235   LCD_D7          EQU P0.3
002E            236   
                238   	$LIST
00E2            240   
00E2            241   ; Flags that are used to control events 
0000            242   BSEG 
0000            243   mf              : dbit 1
0001            244   IN_MENU_FLAG    : dbit 1
0002            245   IN_OVEN_FLAG    : dbit 1
0003            246   REFLOW_FLAG     : dbit 1
0004            247   
0004            248   ; Variables used for push button mux
0004            249   PB_START_PIN        : dbit 1
0005            250   PB_CHANGE_MENU_PIN  : dbit 1
0006            251   PB_INC_TEMP_PIN     : dbit 1
0007            252   PB_INC_TIME_PIN     : dbit 1
0008            253   PB_STOP_PIN         : dbit 1
0009            254   
                547   $LIST
                256   $LIST
0352            258   
0352            259   ; Messages to display on LCD when in Menu FSM
0352 5265666C   260   LCD_defaultTop  : db 'Reflow Oven: ', 0
     6F77204F
     76656E3A
     2000
0360 53746172   261   LCD_defaultBot  : db 'Start/Configure?', 0
     742F436F
     6E666967
     7572653F
     00
0371 536F616B   262   LCD_soakTime    : db 'Soak Time: ', 0
     2054696D
     653A2000
037D 536F616B   263   LCD_soakTemp    : db 'Soak Temp: ', 0
     2054656D
     703A2000
0389 5265666C   264   LCD_reflowTime  : db 'Refl Time: ', 0
     2054696D
     653A2000
0395 5265666C   265   LCD_reflowTemp  : db 'Refl Temp: ', 0
     2054656D
     703A2000
03A1 54455354   266   LCD_TEST        : db 'TEST MESSAGE ', 0
     204D4553
     53414745
     2000
03AF 20202020   267   LCD_clearLine   : db '                ', 0 ; put at end to clear line
     20202020
     20202020
     20202020
     00
03C0            268   
03C0 50726568   269   preheatMessage  : db 'Preheat', 0
     65617400
03C8 536F616B   270   soakMessage     : db 'Soak', 0
     00
03CD 5065616B   271   ramp2peakMessage: db 'Peak to Soak', 0
     20746F20
     536F616B
     00
03DA 5265666C   272   reflowMessage   : db 'Reflow', 0
     6F7700
03E1 436F6F6C   273   coolingMessage  : db 'Cooling', 0
     696E6700
03E9 46696E69   274   FinishedMessage : db 'Finished!', 0
     73686564
     2100
03F3 454D4552   275   stopMessage     : db 'EMERGENCY STOP', 0
     47454E43
     59205354
     4F5000
0402            276   
0402            277   ; -- Debug messages
0402            278   ; seonds_passed   : db 'Seconds: ', 0
0402            279   ; temp            : db 'Temp: ', 0
0402            280   ; ovenState       : db 'State: ', 0
0402            281   ; errorMessage    : db '** ERROR **', 0
0402            282   
0402            283   emergency:
0402 456D6572   284       DB  'Emergency Stop!', '\r', '\n', 0
     67656E63
     79205374
     6F70210D
     0A00
0414            285   
0414            286   
0414            287   ; Messages to display on LCD when in Oven Controller FSM
0414            288   
0414            289   ; Send a character using the serial port
0414            290   putchar:
0414 3099FD     291           jnb     TI, putchar
0417 C299       292           clr     TI
0419 F599       293           mov     SBUF, a
041B 22         294           ret
041C            295   
041C            296   ; Send a constant-zero-terminated string using the serial port
041C            297   SendString:
041C E4         298           clr     A
041D 93         299           movc    A, @A+DPTR
041E 6006       300           jz      SendStringDone
0420 120414     301           lcall   putchar
0423 A3         302           inc     DPTR
0424 80F6       303           sjmp    SendString
0426            304   SendStringDone:
0426 22         305           ret
0427            306   
0427            307   ; Eight bit number to display passed in ’a’.
0427            308   SendToLCD:
0427 75F064     309           mov     b, #100
042A 84         310           div     ab
042B 4430       311           orl     a, #0x30 ; Convert hundreds to ASCII
042D 12007D     312           lcall   ?WriteData ; Send to LCD
0430 E5F0       313           mov     a, b ; Remainder is in register b
0432 75F00A     314           mov     b, #10
0435 84         315           div     ab
0436 4430       316           orl     a, #0x30 ; Convert tens to ASCII
0438 12007D     317           lcall   ?WriteData; Send to LCD
043B E5F0       318           mov     a, b
043D 4430       319           orl     a, #0x30 ; Convert units to ASCII
043F 12007D     320           lcall   ?WriteData; Send to LCD
0442 22         321           ret
0443            322   
0443            323   ; Eight bit number to display passed in ’a’.
0443            324   SendToSerialPort:
0443 75F064     325           mov     b, #100
0446 84         326           div     ab
0447 4430       327           orl     a, #0x30 ; Convert hundreds to ASCII
0449 120414     328           lcall   putchar ; Send to PuTTY/Python/Matlab
044C E5F0       329           mov     a, b ; Remainder is in register b
044E 75F00A     330           mov     b, #10
0451 84         331           div     ab
0452 4430       332           orl     a, #0x30 ; Convert tens to ASCII
0454 120414     333           lcall   putchar ; Send to PuTTY/Python/Matlab
0457 E5F0       334           mov     a, b
0459 4430       335           orl     a, #0x30 ; Convert units to ASCII
045B 120414     336           lcall   putchar ; Send to PuTTY/Python/Matlab
045E 22         337           ret
045F            338   
045F            339   
045F            340   
045F            341   ;---------------------------------;
045F            342   ; Routine to initialize the ISR   ;
045F            343   ; for timer 0                     ;
045F            344   ;---------------------------------;
045F            345   Timer0_Init:
045F 438E08     346            orl     CKCON, #0b00001000 ; Input for timer 0 is sysclk/1 ; performs bit masking on CKON - Clock Control ; T0M = 1, timer 0 uses the system clock directly
0462 E589       347            mov     a, TMOD
0464 54F0       348            anl     a, #0xf0 ; 11110000 Clear the bits for timer 0
0466 4401       349            orl     a, #0x01 ; 00000001 Configure timer 0 as 16-timer (M1M0 = 01 -> Mode 1: 16-bit Timer/Counter)
0468 F589       350            mov     TMOD, a
046A 758CF0     351            mov     TH0, #high(TIMER0_RELOAD) ; 8051 works with 8 bits so the oepration T0 = TIMER0_RELOAD  (16 bits) is done by setting high byte then low byte (8x2)
046D 758A2C     352            mov     TL0, #low (TIMER0_RELOAD)
0470            353            ; Enable the timer and interrupts
0470 D2A9       354           setb    ET0  ; Enable timer 0 interrupt
0472 D28C       355           setb    TR0  ; Start timer 0
0474 22         356            ret
0475            357   
0475            358   ;---------------------------------;
0475            359   ; Routine to initialize the ISR   ;
0475            360   ; for timer 2                     ;
0475            361   ;---------------------------------;
0475            362   Timer2_Init:
0475 75C800     363            mov     T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0478 75CDBF     364            mov     TH2, #high(TIMER2_RELOAD)
047B 75CC28     365            mov     TL2, #low(TIMER2_RELOAD)
047E            366            ; Set the reload value
047E 43C980     367            orl     T2MOD, #0x80 ; Enable timer 2 autoreload
0481 75CBBF     368            mov     RCMP2H, #high(TIMER2_RELOAD)
0484 75CA28     369            mov     RCMP2L, #low(TIMER2_RELOAD)
0487            370            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0487 E4         371            clr     a
0488 F54A       372            mov     Count1ms+0, a
048A F54B       373            mov     Count1ms+1, a
048C            374            ; Enable the timer and interrupts
048C 439B80     375            orl     EIE, #0x80 ; Enable timer 2 interrupt ET2=1
048F D2CA       376           setb    TR2  ; Enable timer 2
0491 22         377            ret
0492            378   
0492            379   Timer0_ISR:
0492 32         380           reti
0493            381   
0493            382   ;---------------------------------;
0493            383   ; ISR for timer 2                 ;
0493            384   ;---------------------------------;
0493            385   Timer2_ISR:
0493 C2CF       386           clr     TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0495 B284       387           cpl     P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0497            388   
0497            389           ; The two registers used in the ISR must be saved in the stack
0497 C0E0       390           push    acc
0499 C0D0       391           push    psw
049B            392   
049B 054C       393           inc     Count1ms_PWM
049D            394   
049D            395           ; Increment the 16-bit one mili second counter
049D 054A       396           inc     Count1ms+0    ; Increment the low 8-bits first
049F E54A       397           mov     a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
04A1 7002       398           jnz     Inc_done
04A3 054B       399           inc     Count1ms+1
04A5            400    
04A5            401           
04A5            402           Inc_done:
04A5 E54C       403           mov    a, Count1ms_PWM
04A7 B40A15     404           cjne   a, #10, check1secondsPassed 
04AA            405   
04AA            406                   ;RK working on PWM
04AA 054F       407                   inc     pwm_counter
04AC C3         408                   clr     c
04AD E550       409                   mov     a, pwm
04AF 954F       410                   subb    a, pwm_counter ; If pwm_counter <= pwm then c=1
04B1 B3         411                   cpl     c
04B2 9292       412                   mov     PWM_OUT, c 
04B4 E54F       413                   mov     a, pwm_counter
04B6 B46436     414                   cjne    a, #100, Timer2_ISR_done
04B9 754F00     415                   mov     pwm_counter, #0
04BC            416   
04BC E4         417                   clr     a
04BD F54C       418                   mov     Count1ms_PWM, a
04BF            419           
04BF            420           
04BF            421           check1secondsPassed:
04BF            422           ; Check if one second has passed
04BF E54A       423            mov     a, Count1ms+0
04C1 B4E82B     424            cjne    a, #low(1000), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
04C4 E54B       425            mov     a, Count1ms+1
04C6 B40326     426            cjne    a, #high(1000), Timer2_ISR_done         
04C9            427   
04C9            428           ; ---  1s has passed ----
04C9            429   
04C9 1205B0     430           lcall DO_TEMP_READ
04CC            431           ; lcall send_temp_to_serial
04CC            432           
04CC            433           ; ---- Log File -----
04CC E54D       434           mov a,  seconds_elapsed
04CE 120443     435           lcall   SendToSerialPort
04D1 740D       436           mov a,  #'\r' ; Return character
04D3 120414     437           lcall   putchar
04D6 740A       438           mov a,  #'\n' ; New-line character
04D8 120414     439           lcall   putchar
04DB            440   
04DB            441           ; mov a,  OVEN_STATE
04DB            442           ; lcall   SendToSerialPort
04DB            443           ; mov a,  #'\r' ; Return character
04DB            444           ; lcall   putchar
04DB            445           ; mov a,  #'\n' ; New-line character
04DB            446           ; lcall   putchar
04DB            447           
04DB            448   
04DB            449           ; mov a, OVEN_STATE
04DB            450           ; add A, #1
04DB            451           ; mov OVEN_STATE, a
04DB 300306     452           jnb     REFLOW_FLAG,  not_in_reflow ;Checks if we are in reflow state
04DE E54E       453           mov     a, exit_seconds             ;Increments the early exit seconds counter
04E0 2401       454           add     a, #1
04E2 F54E       455           mov     exit_seconds, a
04E4            456           
04E4            457    not_in_reflow:
04E4 E54D       458           mov     a, seconds_elapsed
04E6 2401       459           add     A, #1
04E8 F54D       460           mov     seconds_elapsed, a
04EA            461   
04EA            462           ; reset seconds ms counter
04EA E4         463           clr     a
04EB F54A       464           mov     Count1ms+0, a
04ED F54B       465           mov     Count1ms+1, a
04EF            466   
04EF            467           Timer2_ISR_done:
04EF D0D0       468           pop     psw
04F1 D0E0       469            pop     acc
04F3 32         470           reti
04F4            471   
04F4            472   
04F4            473   Display_formated_BCD:
04F4 C0E0       474            push acc
04F6 7406       474            mov a, #6
04F8 14         474            dec a
04F9 1200C5     474            lcall ?Set_Cursor_2 ; Select column and row
04FC D0E0       474            pop acc
04FE C000       475            push ar0
0500 A83B       475            mov r0, bcd+3
0502 1200CC     475            lcall ?Display_BCD
0505 D000       475            pop ar0
0507 C000       476            push ar0
0509 A83A       476            mov r0, bcd+2
050B 1200CC     476            lcall ?Display_BCD
050E D000       476            pop ar0
0510 C0E0       477            push acc
0512 742E       477            mov a, #'.'
0514 12007D     477            lcall ?WriteData
0517 D0E0       477            pop acc
0519 C000       478            push ar0
051B A839       478            mov r0, bcd+1
051D 1200CC     478            lcall ?Display_BCD
0520 D000       478            pop ar0
0522 C000       479            push ar0
0524 A838       479            mov r0, bcd+0
0526 1200CC     479            lcall ?Display_BCD
0529 D000       479            pop ar0
052B 22         480   ret
052C            481   
052C            482   
052C            483   InitSerialPort:
052C            484       ; Since the reset button bounces, we need to wait a bit before
052C            485       ; sending messages, otherwise we risk displaying gibberish!
052C 79C8       486       mov R1, #200
052E 7868       487       mov R0, #104
0530 D8FE       488       djnz R0, $   ; 4 cycles->4*60.285ns*104=25us
0532 D9FA       489       djnz R1, $-4 ; 25us*200=5.0ms
0534            490   
0534            491       ; Now we can proceed with the configuration of the serial port
0534 438E10     492            orl     CKCON, #0x10 ; CLK is the input for timer 1
0537 438780     493            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
053A 759852     494            mov     SCON, #0x52
053D 53C4DF     495            anl     T3CON, #0b11011111
0540 53890F     496            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
0543 438920     497            orl     TMOD, #0x20 ; Timer 1 Mode 2
0546 758DF7     498            mov     TH1, #TIMER1_RELOAD
0549 D28E       499            setb TR1
054B 22         500           ret
054C            501           
054C            502   ;jesus' beautiful averaging code, can be used in place of Read_ADC in place where we read
054C            503   Average_ADC:
054C 753000     504            mov x+0, #low (0 % 0x10000) 
054F 753100     504            mov x+1, #high(0 % 0x10000) 
0552 753200     504            mov x+2, #low (0 / 0x10000) 
0555 753300     504            mov x+3, #high(0 / 0x10000) 
0558 7D64       505           mov R5, #100
055A 7E64       506           mov R6, #100
055C            507   
055C            508           Sum_loop0:
055C 120595     509           lcall Read_ADC
055F 753700     510           mov y+3, #0
0562 753600     511           mov y+2, #0
0565 8935       512           mov y+1, R1
0567 8834       513           mov y+0, R0
0569            514   
0569 C030       515           push x
056B 7530FC     516            mov x+0, #low (34300 % 0x10000) 
056E 753185     516            mov x+1, #high(34300 % 0x10000) 
0571 753200     516            mov x+2, #low (34300 / 0x10000) 
0574 753300     516            mov x+3, #high(34300 / 0x10000) 
0577 120252     517           lcall x_lteq_y
057A 200007     518           jb mf, skipval
057D D030       519           pop x
057F            520   
057F 1201A7     521           lcall add32
0582 DDD8       522           djnz R5, Sum_loop0
0584            523   
0584            524           skipval:
0584 DED6       525                  djnz R6, Sum_loop0
0586            526   
0586            527           ;load_y(100)
0586 753700     528           mov y+3, #0
0589 753600     529           mov y+2, #0
058C 753500     530           mov y+1, #0
058F 8E34       531           mov y+0, R6
0591 1202E9     532           lcall div32
0594 22         533           ret
0595            534   
0595            535   
0595            536   Read_ADC:
0595 C2EF       537           clr ADCF
0597 D2EE       538           setb ADCS ;  ADC start trigger signal
0599 30EFFD     539           jnb ADCF, $ ; Wait for conversion complete
059C            540           
059C            541           ; Read the ADC result and store in [R1, R0]
059C E5C2       542           mov a, ADCRL
059E 540F       543           anl a, #0x0f
05A0 F8         544           mov R0, a
05A1 E5C3       545           mov a, ADCRH  
05A3 C4         546           swap a
05A4 C0E0       547           push acc
05A6 540F       548           anl a, #0x0f
05A8 F9         549           mov R1, a
05A9 D0E0       550           pop acc
05AB 54F0       551           anl a, #0xf0
05AD 48         552           orl a, R0
05AE F8         553           mov R0, A
05AF 22         554   ret
05B0            555   
05B0            556   DO_TEMP_READ:
05B0            557           ;push x
05B0            558           ; Read the 2.08V LED voltage connected to AIN0 on pin 6
05B0 53E8F0     559           anl ADCCON0, #0xF0
05B3 43E800     560           orl ADCCON0, #0x00 ; Select channel 0
05B6            561   
05B6 120595     562           lcall Read_ADC
05B9            563           ; Save result for later use
05B9 8842       564           mov VLED_ADC+0, R0
05BB 8943       565           mov VLED_ADC+1, R1
05BD            566   
05BD            567           ; Read the signal connected to AIN7
05BD 53E8F0     568           anl ADCCON0, #0xF0
05C0 43E807     569           orl ADCCON0, #0x07 ; Select channel 7
05C3            570           ;lcall Read_ADC
05C3 12054C     571           lcall Average_ADC ;using in place of Read_ADC function, takes 100 measurements and averages
05C6            572                             ;fairly instantaneous reading 
05C6            573   
05C6            574           ; Convert to voltage
05C6 8830       575           mov x+0, R0
05C8 8931       576           mov x+1, R1
05CA            577           ; Pad other bits with zero
05CA 753200     578           mov x+2, #0
05CD 753300     579           mov x+3, #0
05D0 753414     580            mov y+0, #low (20500 % 0x10000) 
05D3 753550     580            mov y+1, #high(20500 % 0x10000) 
05D6 753600     580            mov y+2, #low (20500 / 0x10000) 
05D9 753700     580            mov y+3, #high(20500 / 0x10000)  ; The MEASURED LED voltage: 2.074V, with 4 decimal places
05DC 12025C     581           lcall mul32
05DF            582           ; Retrive the ADC LED value
05DF 854234     583           mov y+0, VLED_ADC+0
05E2 854335     584           mov y+1, VLED_ADC+1
05E5            585           ; Pad other bits with zero
05E5 753600     586           mov y+2, #0
05E8 753700     587           mov y+3, #0
05EB 1202E9     588           lcall div32 ; x stores thermocouple voltage
05EE            589   
05EE 753451     590            mov y+0, #low (81 % 0x10000) 
05F1 753500     590            mov y+1, #high(81 % 0x10000) 
05F4 753600     590            mov y+2, #low (81 / 0x10000) 
05F7 753700     590            mov y+3, #high(81 / 0x10000) 
05FA 12025C     591           lcall mul32
05FD            592   
05FD            593           ; code to use temp sensor for amb temp
05FD            594           ;push x
05FD            595   ;
05FD            596           ;anl ADCCON0, #0xF0
05FD            597           ;orl ADCCON0, #0x01 ; Select channel 1
05FD            598           ;lcall Read_ADC
05FD            599   ;
05FD            600           ;mov x+0, R0
05FD            601           ;mov x+1, R1
05FD            602           ;; Pad other bits with zero
05FD            603           ;mov x+2, #0
05FD            604           ;mov x+3, #0
05FD            605           ;Load_y(20500) ; The MEASURED LED voltage: 2.074V, with 4 decimal places
05FD            606           ;lcall mul32
05FD            607           ;; Retrive the ADC LED value
05FD            608           ;mov y+0, VLED_ADC+0
05FD            609           ;mov y+1, VLED_ADC+1
05FD            610           ;; Pad other bits with zero
05FD            611           ;mov y+2, #0
05FD            612           ;mov y+3, #0
05FD            613           ;lcall div32
05FD            614   ;
05FD            615           ;load_y(100)
05FD            616           ;lcall mul32
05FD            617           ;
05FD            618           ;
05FD            619           ;load_y(273000)
05FD            620           ;lcall sub32
05FD            621   ;
05FD            622           ;mov y+0, x+0
05FD            623           ;mov y+1, x+1
05FD            624           ;mov y+2, x+2
05FD            625           ;mov y+3, x+3
05FD            626   ;
05FD            627           ;lcall hex2bcd
05FD            628           ;lcall send_temp_to_serial
05FD            629   ;
05FD            630           ;pop x
05FD            631           
05FD 753460     632            mov y+0, #low (220000 % 0x10000) 
0600 75355B     632            mov y+1, #high(220000 % 0x10000) 
0603 753603     632            mov y+2, #low (220000 / 0x10000) 
0606 753700     632            mov y+3, #high(220000 / 0x10000)  ;adding 22, will change to ambient later
0609 1201A7     633           lcall add32
060C            634   
060C 22         635           ret
060D            636   
060D            637   ;---------------------------------;
060D            638   ; Send a BCD number to PuTTY      ;
060D            639   ;---------------------------------;
                640   Send_BCD mac
                641   	push    ar0
                642   	mov     r0, %0
                643   	lcall   ?Send_BCD
                644   	pop     ar0
                645   	endmac
060D            646            ?Send_BCD:
060D C0E0       647                   push    acc
060F            648                   ; Write most significant digit
060F E8         649                   mov     a, r0
0610 C4         650                   swap    a
0611 540F       651                   anl     a, #0fh
0613 4430       652                   orl     a, #30h
0615 120414     653                   lcall   putchar
0618            654                   ; write least significant digit
0618 E8         655                   mov     a, r0
0619 540F       656                   anl     a, #0fh
061B 4430       657                   orl     a, #30h
061D 120414     658                   lcall   putchar
0620 D0E0       659                   pop     acc
0622 22         660   ret
0623            661   
0623            662   ; oven_FSM_LCD_DISPLAY (message)
0623            663   ; Params
0623            664   ;       message - constant string dataByte
                665   oven_FSM_LCD_DISPLAY MAC
                666           ; Display mode and temperature on line 1
                667           Set_Cursor(1,1)
                668           Send_Constant_String(%0)
                669           Send_Constant_String(#LCD_clearLine)
                670   
                671           ; display seconds on line 2
                672           Set_Cursor(2, 1)
                673           mov     a, seconds_elapsed
                674   ENDMAC
0623            675   
0623            676   
0623            677   send_temp_to_serial:
0623 C000       678            push    ar0
0625 A83B       678            mov     r0, bcd+3
0627 12060D     678            lcall   ?Send_BCD
062A D000       678            pop     ar0
062C C000       679            push    ar0
062E A83A       679            mov     r0, bcd+2
0630 12060D     679            lcall   ?Send_BCD
0633 D000       679            pop     ar0
0635 C000       680            push    ar0
0637 A839       680            mov     r0, bcd+1
0639 12060D     680            lcall   ?Send_BCD
063C D000       680            pop     ar0
063E C000       681            push    ar0
0640 A838       681            mov     r0, bcd+0
0642 12060D     681            lcall   ?Send_BCD
0645 D000       681            pop     ar0
0647            682   
0647 740D       683           mov a,  #'\r' ; Return character
0649 120414     684           lcall   putchar
064C 740A       685           mov a,  #'\n' ; New-line character
064E 120414     686           lcall   putchar
0651            687   
0651 22         688           ret 
0652            689   
0652            690   Initilize_All:
0652            691           ; Configure pins to be bi-directional
0652 75AC00     692           mov      P3M1,#0x00
0655 75AD00     693            mov     P3M2,#0x00
0658 75B300     694            mov     P1M1,#0x00
065B 75B400     695            mov     P1M2,#0x00
065E 75B100     696            mov     P0M1,#0x00
0661 75B200     697            mov     P0M2,#0x00
0664            698   
0664 D281       699           setb    CHANGE_MENU_PIN
0666 D293       700           setb    START_PIN
0668            701   
0668 D2AF       702           setb    EA   ; Enable Global interrupts
066A            703   
066A            704   
066A            705           ; Since the reset button bounces, we need to wait a bit before
066A            706           ; sending messages, otherwise we risk displaying gibberish!
066A C002       707            push AR2
066C 7A32       707            mov R2, #50
066E 120038     707            lcall ?Wait_Milli_Seconds
0671 D002       707            pop AR2
0673            708   
0673            709           ; Now we can proceed with the configuration of the serial port
0673 438E10     710           orl      CKCON, #0x10 ; CLK is the input for timer 1
0676 438780     711           orl      PCON, #0x80  ; Bit SMOD=1, double baud rate
0679 759852     712           mov      SCON, #0x52
067C 53C4DF     713           anl      T3CON, #0b11011111
067F 53890F     714           anl      TMOD, #0x0F ; Clear the configuration bits for timer 1
0682 438920     715           orl      TMOD, #0x20 ; Timer 1 Mode 2
0685 758DF7     716           mov      TH1, #TIMER1_RELOAD
0688 D28E       717           setb    TR1
068A            718   
068A            719           ; ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ SUS  ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓   
068A            720           ; works on its own from lab3, might interfere with other stuff though       ; NOTE TIMER ZERO HAS NOT YET BEEN TESTED       
068A            721           ; Using timer 0 for delay functions.  Initialize here:
068A C28C       722            clr     TR0         ; Stop timer 0
068C 438E08     723            orl     CKCON,#0x08 ; CLK is the input for timer 0
068F 5389F0     724            anl     TMOD,#0xF0  ; Clear the configuration bits for timer 0
0692 438901     725            orl     TMOD,#0x01  ; Timer 0 in Mode 1: 16-bit timer
0695            726           ; ^ ^ ^ ^ ^ ^ ^ ^^ ^ ^ ^ ^ ^^ ^ ^ ^ ^^ ^ ^ ^            
0695            727            
0695            728            ; Initialize the pins used by the ADC (P1.1, P1.7) as input.
0695 43B382     729            orl     P1M1, #0b10000010
0698 53B47D     730            anl     P1M2, #0b01111101
069B            731            
069B            732            ; Initialize and start the ADC:
069B 53E8F0     733            anl     ADCCON0, #0xF0
069E 43E807     734            orl     ADCCON0, #0x07 ; Select channel 7
06A1            735            
06A1            736           ; AINDIDS select if some pins are analog inputs or digital I/O:
06A1 75F600     737            mov     AINDIDS, #0x00 ; Disable all analog inputs
06A4 43F681     738            orl     AINDIDS, #0b10000001 ; Activate AIN0 and AIN7 analog inputs
06A7 43E101     739            orl     ADCCON1, #0x01 ; Enable ADC
06AA            740   
06AA            741           ; Menu Configuration
06AA C201       742           clr     IN_MENU_FLAG
06AC C202       743           clr     IN_OVEN_FLAG
06AE 7400       744           mov     a, #0
06B0 F545       745           mov     MENU_STATE, a ; set menu state to 0 
06B2            746   
06B2            747           ; mov     temp_soak, #0x250
06B2 754696     748           mov     temp_soak, #150
06B5 754705     749           mov     time_soak, #MIN_TIME
06B8 7548DC     750           mov     temp_refl, #220
06BB 754905     751           mov     time_refl, #MIN_TIME
06BE            752           
06BE            753           ; Oven configuration
06BE 754400     754           mov     OVEN_STATE, #OVEN_STATE_PREHEAT
06C1 754D00     755           mov     seconds_elapsed, #0
06C4 754C00     756           mov     Count1ms_PWM, #0
06C7 754E00     757           mov     exit_seconds, #0
06CA C203       758           clr     REFLOW_FLAG
06CC            759   
06CC            760           ; clear x
06CC 753000     761           mov x+0, #0
06CF 753100     762           mov x+1, #0
06D2 753200     763           mov x+2, #0
06D5 753300     764           mov x+3, #0
06D8            765           
06D8 22         766           ret
06D9            767   
06D9            768   STOP_PROCESS:
06D9            769           ; Turn everything off
06D9 C203       770           clr     REFLOW_FLAG
06DB C202       771           clr     IN_OVEN_FLAG
06DD C201       772           clr     IN_MENU_FLAG
06DF 754400     773           MOV     OVEN_STATE, #OVEN_STATE_PREHEAT
06E2 754D00     774           MOV     seconds_elapsed, #0
06E5 754C00     775           mov     Count1ms_PWM, #0
06E8 754E00     776           mov     exit_seconds, #0
06EB 755000     777           MOV     pwm, #0
06EE            778   
06EE 900402     779           mov DPTR, #emergency
06F1 12041C     780           lcall SendString
06F4            781   
06F4 C2CA       782           clr     TR2 ; disable timer 2 so that it doesn't count up in background
06F6 020C0C     783           ljmp    PROGRAM_ENTRY
06F9            784   
06F9            785   ; Precondition: Has temperature stored in x
06F9            786   OVEN_FSM:
06F9 C002       787            push AR2
06FB 7A32       787            mov R2, #50
06FD 120038     787            lcall ?Wait_Milli_Seconds
0700 D002       787            pop AR2
0702            788           
0702 D204       789           setb PB_START_PIN
0704 D205       789           setb PB_CHANGE_MENU_PIN
0706 D206       789           setb PB_INC_TEMP_PIN
0708 D207       789           setb PB_INC_TIME_PIN
070A D208       789           setb PB_STOP_PIN
070C            789           
070C D295       789           setb SHARED_PIN
070E            789           ; check if any push buttons are pressed
070E C293       789           clr START_PIN             
0710 C281       789           clr CHANGE_MENU_PIN       
0712 C282       789           clr INC_TEMP_PIN          
0714 C283       789           clr INC_TIME_PIN          
0716 C280       789           clr STOP_PIN
0718            789   
0718            789           ; debounce
0718 209544     789           jb SHARED_PIN, enterOvenStateCheck ; use helper label to jump to the end
071B C002       789            push AR2
071D 7A32       789            mov R2, #50
071F 120038     789            lcall ?Wait_Milli_Seconds
0722 D002       789            pop AR2
0724 209538     789           jb SHARED_PIN, enterOvenStateCheck
0727            789   
0727            789           ; Set the LCD data pins to logic 1
0727 D293       789           setb START_PIN
0729 D281       789           setb CHANGE_MENU_PIN
072B D282       789           setb INC_TEMP_PIN
072D D283       789           setb INC_TIME_PIN
072F D280       789           setb STOP_PIN
0731            789   
0731            789           ; check push buttons 1 by one
0731 C293       789           clr START_PIN
0733 A295       789           mov c, SHARED_PIN
0735 9204       789           mov PB_START_PIN, c
0737 D293       789           setb START_PIN
0739            789   
0739 C281       789           clr CHANGE_MENU_PIN
073B A295       789           mov c, SHARED_PIN
073D 9205       789           mov PB_CHANGE_MENU_PIN, c
073F D281       789           setb CHANGE_MENU_PIN
0741            789   
0741 C282       789           clr INC_TEMP_PIN
0743 A295       789           mov c, SHARED_PIN
0745 9206       789           mov PB_INC_TEMP_PIN, c
0747 D282       789           setb INC_TEMP_PIN
0749            789   
0749 C283       789           clr INC_TIME_PIN
074B A295       789           mov c, SHARED_PIN
074D 9207       789           mov PB_INC_TIME_PIN, c
074F D283       789           setb INC_TIME_PIN
0751            789   
0751 C280       789           clr STOP_PIN
0753 A295       789           mov c, SHARED_PIN
0755 9208       789           mov PB_STOP_PIN, c
0757 D280       789           setb STOP_PIN
0759            789   
0759 200803     789           jb PB_STOP_PIN, enterOvenStateCheck ; check that the variable flag is not 1, otherwise jmp
075C            789   
075C            789   
075C 1206D9     790           lcall   STOP_PROCESS
075F            791   
075F            792           ; check oven state if stop button is not pressed
075F            793           enterOvenStateCheck:
075F E544       794                   mov  a, OVEN_STATE
0761            795                   ; setb STOP_PIN
0761            796           
0761            797           ovenFSM_preheat:
0761            798                   ; long jump for relative offset
0761 B40002     799                   cjne    a, #OVEN_STATE_PREHEAT, ovenFSM_soak_jmp
0764 8003       800                   sjmp    oven_state_preheat_tasks
0766            801                   ovenFSM_soak_jmp:
0766 0207E6     802                           ljmp    ovenFSM_soak
0769            803                   oven_state_preheat_tasks:
0769 75501E     804                           mov     pwm, #30
076C C0E0       805            push acc
076E 7401       805            mov a, #1
0770 14         805            dec a
0771 1200C7     805            lcall ?Set_Cursor_1 ; Select column and row
0774 D0E0       805            pop acc
0776 C083       806            push dph
0778 C082       806            push dpl
077A C0E0       806            push acc
077C 9003C0     806            mov dptr, #preheatMessage
077F 1200BA     806            lcall ?Send_Constant_String
0782 D0E0       806            pop acc
0784 D082       806            pop dpl
0786 D083       806            pop dph
0788 C083       807            push dph
078A C082       807            push dpl
078C C0E0       807            push acc
078E 9003AF     807            mov dptr, #LCD_clearLine
0791 1200BA     807            lcall ?Send_Constant_String
0794 D0E0       807            pop acc
0796 D082       807            pop dpl
0798 D083       807            pop dph
079A C0E0       808            push acc
079C 7401       808            mov a, #1
079E 14         808            dec a
079F 1200C5     808            lcall ?Set_Cursor_2 ; Select column and row
07A2 D0E0       808            pop acc
07A4 E54D       809                           mov     a, seconds_elapsed
07A6 120427     810                           lcall   SendToLCD ; send seconds to LCD
07A9            811   
07A9 1200E2     812                           lcall   hex2bcd
07AC            813                           ; lcall   send_temp_to_serial
07AC 1204F4     814                           lcall   Display_formated_BCD
07AF            815   
07AF            816                   ;Emergency exit process; tested, works
07AF D203       817                   setb    REFLOW_FLAG
07B1 E54E       818                   mov     a, exit_seconds
07B3 B43C15     819                   cjne    a, #60, Skip_Emergency_exit
07B6 753420     820            mov y+0, #low (50*10000 % 0x10000) 
07B9 7535A1     820            mov y+1, #high(50*10000 % 0x10000) 
07BC 753607     820            mov y+2, #low (50*10000 / 0x10000) 
07BF 753700     820            mov y+3, #high(50*10000 / 0x10000) 
07C2 120248     821                   lcall   x_gteq_y
07C5 200003     822                   jb      mf, Skip_Emergency_exit ; if x > y, don't exit
07C8            823                   
07C8            824                   ; mov a, temp
07C8            825                   ; lcall ;send temperature value to serial
07C8 0206D9     826                   ljmp    STOP_PROCESS ; more then 60 seconds has elapsed and we are below 50C ESCAPE
07CB            827                   
07CB            828           Skip_Emergency_exit:       
07CB            829                   ; check temperature has reached configured value 
07CB            830                   ; temp_gt_threshold(temp_soak, #OVEN_STATE_SOAK)
07CB            831                   ; load_y(temp_soak*10000*2)
07CB 753400     832            mov y+0, #low (80*10000 % 0x10000) 
07CE 753535     832            mov y+1, #high(80*10000 % 0x10000) 
07D1 75360C     832            mov y+2, #low (80*10000 / 0x10000) 
07D4 753700     832            mov y+3, #high(80*10000 / 0x10000) 
07D7            833   
07D7 120206     834                   lcall x_gt_y
07DA 300006     835                   jnb mf, noChange_preHeat ; jump past the jnb and mov instructions which are both 3 bytes
07DD 754401     836                   mov OVEN_STATE, #OVEN_STATE_SOAK
07E0 754D00     837                   mov seconds_elapsed, #0
07E3            838           noChange_preHeat:
07E3 0209C9     839                   ljmp oven_FSM_done
07E6            840           
07E6            841           ovenFSM_soak:
07E6 B40154     842                   cjne    a, #OVEN_STATE_SOAK, ovenFSM_Ramp2Peak
07E9 755014     843                   mov     pwm, #20
07EC C0E0       844            push acc
07EE 7401       844            mov a, #1
07F0 14         844            dec a
07F1 1200C7     844            lcall ?Set_Cursor_1 ; Select column and row
07F4 D0E0       844            pop acc
07F6 C083       845            push dph
07F8 C082       845            push dpl
07FA C0E0       845            push acc
07FC 9003C8     845            mov dptr, #soakMessage
07FF 1200BA     845            lcall ?Send_Constant_String
0802 D0E0       845            pop acc
0804 D082       845            pop dpl
0806 D083       845            pop dph
0808 C083       846            push dph
080A C082       846            push dpl
080C C0E0       846            push acc
080E 9003AF     846            mov dptr, #LCD_clearLine
0811 1200BA     846            lcall ?Send_Constant_String
0814 D0E0       846            pop acc
0816 D082       846            pop dpl
0818 D083       846            pop dph
081A C0E0       847            push acc
081C 7401       847            mov a, #1
081E 14         847            dec a
081F 1200C5     847            lcall ?Set_Cursor_2 ; Select column and row
0822 D0E0       847            pop acc
0824 E54D       848                   mov     a, seconds_elapsed
0826 120427     849                   lcall   SendToLCD
0829            850                   
0829 1200E2     851                   lcall   hex2bcd
082C 1204F4     852                   lcall   Display_formated_BCD
082F            853   
082F            854                   ; check if seconds elapsed > soak time
082F E54D       855                   mov     a, seconds_elapsed
0831 B54706     856                   cjne    a, time_soak, noChange_soakState
0834 754402     857                   mov     OVEN_STATE, #OVEN_STATE_RAMP2PEAK
0837 754D00     858                   mov     seconds_elapsed, #0 ; reset
083A            859                   noChange_soakState:
083A 0209C9     860                           ljmp    oven_FSM_done
083D            861           
083D            862           ovenFSM_Ramp2Peak:
083D B40202     863                   cjne    a, #OVEN_STATE_RAMP2PEAK, ovenFSM_reflow_jmp
0840 8003       864                   sjmp ovenFSM_Ramp2Peak_task
0842            865                   ovenFSM_reflow_jmp:
0842 0208A6     866                   ljmp ovenFSM_reflow
0845            867                   ovenFSM_Ramp2Peak_task:
0845 755064     868                   mov     pwm, #100
0848 C0E0       869            push acc
084A 7401       869            mov a, #1
084C 14         869            dec a
084D 1200C7     869            lcall ?Set_Cursor_1 ; Select column and row
0850 D0E0       869            pop acc
0852 C083       870            push dph
0854 C082       870            push dpl
0856 C0E0       870            push acc
0858 9003CD     870            mov dptr, #ramp2peakMessage
085B 1200BA     870            lcall ?Send_Constant_String
085E D0E0       870            pop acc
0860 D082       870            pop dpl
0862 D083       870            pop dph
0864 C083       871            push dph
0866 C082       871            push dpl
0868 C0E0       871            push acc
086A 9003AF     871            mov dptr, #LCD_clearLine
086D 1200BA     871            lcall ?Send_Constant_String
0870 D0E0       871            pop acc
0872 D082       871            pop dpl
0874 D083       871            pop dph
0876 C0E0       872            push acc
0878 7401       872            mov a, #1
087A 14         872            dec a
087B 1200C5     872            lcall ?Set_Cursor_2 ; Select column and row
087E D0E0       872            pop acc
0880 E54D       873                   mov     a, seconds_elapsed
0882 120427     874                   lcall   SendToLCD
0885            875   
0885 1200E2     876                   lcall   hex2bcd
0888 1204F4     877                   lcall   Display_formated_BCD
088B            878   
088B            879                   ; check that temperature for reflow is reached, then exit 
088B            880                   ; temp_gt_threshold(temp_refl, #OVEN_STATE_REFLOW)
088B 753480     881            mov y+0, #low (120 * 10000 % 0x10000) 
088E 75354F     881            mov y+1, #high(120 * 10000 % 0x10000) 
0891 753612     881            mov y+2, #low (120 * 10000 / 0x10000) 
0894 753700     881            mov y+3, #high(120 * 10000 / 0x10000) 
0897 120206     882                   lcall x_gt_y
089A 300003     883                   jnb mf, $+3+3 ; jump past the jnb and mov instructions which are both 3 bytes
089D 754403     884                   mov OVEN_STATE, #OVEN_STATE_REFLOW
08A0 754D00     885                   mov  seconds_elapsed, #0
08A3 0209C9     886                   ljmp oven_FSM_done
08A6            887                   
08A6            888           ovenFSM_reflow:
08A6 B40354     889                   cjne    a, #OVEN_STATE_REFLOW, ovenFSM_cooling
08A9 755064     890                   mov     pwm, #100
08AC C0E0       891            push acc
08AE 7401       891            mov a, #1
08B0 14         891            dec a
08B1 1200C7     891            lcall ?Set_Cursor_1 ; Select column and row
08B4 D0E0       891            pop acc
08B6 C083       892            push dph
08B8 C082       892            push dpl
08BA C0E0       892            push acc
08BC 9003DA     892            mov dptr, #reflowMessage
08BF 1200BA     892            lcall ?Send_Constant_String
08C2 D0E0       892            pop acc
08C4 D082       892            pop dpl
08C6 D083       892            pop dph
08C8 C083       893            push dph
08CA C082       893            push dpl
08CC C0E0       893            push acc
08CE 9003AF     893            mov dptr, #LCD_clearLine
08D1 1200BA     893            lcall ?Send_Constant_String
08D4 D0E0       893            pop acc
08D6 D082       893            pop dpl
08D8 D083       893            pop dph
08DA C0E0       894            push acc
08DC 7401       894            mov a, #1
08DE 14         894            dec a
08DF 1200C5     894            lcall ?Set_Cursor_2 ; Select column and row
08E2 D0E0       894            pop acc
08E4 E54D       895                   mov     a, seconds_elapsed
08E6 120427     896                   lcall   SendToLCD
08E9            897   
08E9 1200E2     898                   lcall   hex2bcd
08EC 1204F4     899                   lcall   Display_formated_BCD
08EF            900   
08EF            901                   ; check if seconds elapsed > reflow time
08EF E54D       902                   mov     a, seconds_elapsed
08F1 B54906     903                   cjne    a, time_refl, noChange_reflowState
08F4 754404     904                   mov     OVEN_STATE, #OVEN_STATE_COOLING
08F7 754D00     905                   mov     seconds_elapsed, #0 ; reset
08FA            906                   noChange_reflowState:
08FA 0209C9     907                           ljmp    oven_FSM_done
08FD            908   
08FD            909           ovenFSM_cooling:
08FD B40461     910                   cjne    a, #OVEN_STATE_COOLING, ovenFSM_finished
0900 755000     911                   mov     pwm, #0
0903 C0E0       912            push acc
0905 7401       912            mov a, #1
0907 14         912            dec a
0908 1200C7     912            lcall ?Set_Cursor_1 ; Select column and row
090B D0E0       912            pop acc
090D C083       913            push dph
090F C082       913            push dpl
0911 C0E0       913            push acc
0913 9003E1     913            mov dptr, #coolingMessage
0916 1200BA     913            lcall ?Send_Constant_String
0919 D0E0       913            pop acc
091B D082       913            pop dpl
091D D083       913            pop dph
091F C083       914            push dph
0921 C082       914            push dpl
0923 C0E0       914            push acc
0925 9003AF     914            mov dptr, #LCD_clearLine
0928 1200BA     914            lcall ?Send_Constant_String
092B D0E0       914            pop acc
092D D082       914            pop dpl
092F D083       914            pop dph
0931 C0E0       915            push acc
0933 7401       915            mov a, #1
0935 14         915            dec a
0936 1200C5     915            lcall ?Set_Cursor_2 ; Select column and row
0939 D0E0       915            pop acc
093B E54D       916                   mov     a, seconds_elapsed
093D 120427     917                   lcall   SendToLCD
0940            918              
0940 1200E2     919                   lcall   hex2bcd
0943            920                   ; lcall   send_temp_to_serial
0943 1204F4     921                   lcall   Display_formated_BCD
0946            922   
0946            923                   ; once temperature is low (compare with temp constant)
0946 753420     924            mov y+0, #low (50 * 10000 % 0x10000) 
0949 7535A1     924            mov y+1, #high(50 * 10000 % 0x10000) 
094C 753607     924            mov y+2, #low (50 * 10000 / 0x10000) 
094F 753700     924            mov y+3, #high(50 * 10000 / 0x10000) 
0952 1201EA     925                   lcall x_lt_y
0955 300003     926                   jnb mf, $+3+3 ; jump past the jnb and mov instructions which are both 3 bytes
0958 754405     927                   mov OVEN_STATE, #OVEN_STATE_FINISHED
095B 754D00     928                   mov     seconds_elapsed, #0 ; reset
095E 0209C9     929                   ljmp oven_FSM_done
0961            930   
0961            931           ovenFSM_finished:
0961 B4055F     932                   cjne    a, #OVEN_STATE_FINISHED, ovenFSM_exit
0964 C0E0       933            push acc
0966 7401       933            mov a, #1
0968 14         933            dec a
0969 1200C7     933            lcall ?Set_Cursor_1 ; Select column and row
096C D0E0       933            pop acc
096E C083       934            push dph
0970 C082       934            push dpl
0972 C0E0       934            push acc
0974 9003E9     934            mov dptr, #FinishedMessage
0977 1200BA     934            lcall ?Send_Constant_String
097A D0E0       934            pop acc
097C D082       934            pop dpl
097E D083       934            pop dph
0980 C083       935            push dph
0982 C082       935            push dpl
0984 C0E0       935            push acc
0986 9003AF     935            mov dptr, #LCD_clearLine
0989 1200BA     935            lcall ?Send_Constant_String
098C D0E0       935            pop acc
098E D082       935            pop dpl
0990 D083       935            pop dph
0992 C0E0       936            push acc
0994 7401       936            mov a, #1
0996 14         936            dec a
0997 1200C5     936            lcall ?Set_Cursor_2 ; Select column and row
099A D0E0       936            pop acc
099C E54D       937                   mov     a, seconds_elapsed
099E 120427     938                   lcall   SendToLCD
09A1 C083       939            push dph
09A3 C082       939            push dpl
09A5 C0E0       939            push acc
09A7 9003AF     939            mov dptr, #LCD_clearLine
09AA 1200BA     939            lcall ?Send_Constant_String
09AD D0E0       939            pop acc
09AF D082       939            pop dpl
09B1 D083       939            pop dph
09B3            940   
09B3            941   
09B3            942                   ; go back to Start Screen after a certain number of seconds
09B3 E54D       943                   mov     a, seconds_elapsed
09B5 B40508     944                   cjne    a, #FINISHED_SECONDS, noChange_finishedState
09B8 754400     945                   mov OVEN_STATE, #OVEN_STATE_PREHEAT
09BB C28C       946                   clr TR0 
09BD 020C0C     947                   ljmp    PROGRAM_ENTRY
09C0            948                   noChange_finishedState:
09C0 0209C9     949                           ljmp    oven_FSM_done
09C3            950   
09C3            951           ovenFSM_exit:
09C3 754400     952                   mov     OVEN_STATE, #OVEN_STATE_PREHEAT
09C6            953                   ; ljmp oven_FSM_done
09C6 1206D9     954                   lcall   STOP_PROCESS ; Exit oven FSM, turn power off, return to program entry
09C9            955                   
09C9            956           oven_FSM_done:
09C9 0206F9     957                   ljmp    OVEN_FSM ; return to start of oven FSM ; this is a blocking FSM
09CC            958           
09CC 22         959   ret ; technically unncessary
09CD            960   
09CD            961   MENU_FSM: 
09CD            962           ; lcall configure_LCD_multiplexing
09CD E545       963           mov     a, MENU_STATE 
09CF D204       964           setb PB_START_PIN
09D1 D205       964           setb PB_CHANGE_MENU_PIN
09D3 D206       964           setb PB_INC_TEMP_PIN
09D5 D207       964           setb PB_INC_TIME_PIN
09D7 D208       964           setb PB_STOP_PIN
09D9            964           
09D9 D295       964           setb SHARED_PIN
09DB            964           ; check if any push buttons are pressed
09DB C293       964           clr START_PIN             
09DD C281       964           clr CHANGE_MENU_PIN       
09DF C282       964           clr INC_TEMP_PIN          
09E1 C283       964           clr INC_TIME_PIN          
09E3 C280       964           clr STOP_PIN
09E5            964   
09E5            964           ; debounce
09E5 209546     964           jb SHARED_PIN, checkTimeInc ; use helper label to jump to the end
09E8 C002       964            push AR2
09EA 7A32       964            mov R2, #50
09EC 120038     964            lcall ?Wait_Milli_Seconds
09EF D002       964            pop AR2
09F1 20953A     964           jb SHARED_PIN, checkTimeInc
09F4            964   
09F4            964           ; Set the LCD data pins to logic 1
09F4 D293       964           setb START_PIN
09F6 D281       964           setb CHANGE_MENU_PIN
09F8 D282       964           setb INC_TEMP_PIN
09FA D283       964           setb INC_TIME_PIN
09FC D280       964           setb STOP_PIN
09FE            964   
09FE            964           ; check push buttons 1 by one
09FE C293       964           clr START_PIN
0A00 A295       964           mov c, SHARED_PIN
0A02 9204       964           mov PB_START_PIN, c
0A04 D293       964           setb START_PIN
0A06            964   
0A06 C281       964           clr CHANGE_MENU_PIN
0A08 A295       964           mov c, SHARED_PIN
0A0A 9205       964           mov PB_CHANGE_MENU_PIN, c
0A0C D281       964           setb CHANGE_MENU_PIN
0A0E            964   
0A0E C282       964           clr INC_TEMP_PIN
0A10 A295       964           mov c, SHARED_PIN
0A12 9206       964           mov PB_INC_TEMP_PIN, c
0A14 D282       964           setb INC_TEMP_PIN
0A16            964   
0A16 C283       964           clr INC_TIME_PIN
0A18 A295       964           mov c, SHARED_PIN
0A1A 9207       964           mov PB_INC_TIME_PIN, c
0A1C D283       964           setb INC_TIME_PIN
0A1E            964   
0A1E C280       964           clr STOP_PIN
0A20 A295       964           mov c, SHARED_PIN
0A22 9208       964           mov PB_STOP_PIN, c
0A24 D280       964           setb STOP_PIN
0A26            964   
0A26 200505     964           jb PB_CHANGE_MENU_PIN, checkTimeInc ; check that the variable flag is not 1, otherwise jmp
0A29            964    ; increments menu state
0A29 04         965           inc     a
0A2A F545       966           mov     MENU_STATE, a 
0A2C D281       967           setb    CHANGE_MENU_PIN
0A2E            968   
0A2E            969           ; increment is checked with a seperate cascade that's outside the FSM
0A2E            970           ; I wanted to keep FSM state outputs seperate from push button checks - George
0A2E            971           checkTimeInc:
0A2E D204       972           setb PB_START_PIN
0A30 D205       972           setb PB_CHANGE_MENU_PIN
0A32 D206       972           setb PB_INC_TEMP_PIN
0A34 D207       972           setb PB_INC_TIME_PIN
0A36 D208       972           setb PB_STOP_PIN
0A38            972           
0A38 D295       972           setb SHARED_PIN
0A3A            972           ; check if any push buttons are pressed
0A3A C293       972           clr START_PIN             
0A3C C281       972           clr CHANGE_MENU_PIN       
0A3E C282       972           clr INC_TEMP_PIN          
0A40 C283       972           clr INC_TIME_PIN          
0A42 C280       972           clr STOP_PIN
0A44            972   
0A44            972           ; debounce
0A44 209560     972           jb SHARED_PIN, checkTempInc ; use helper label to jump to the end
0A47 C002       972            push AR2
0A49 7A32       972            mov R2, #50
0A4B 120038     972            lcall ?Wait_Milli_Seconds
0A4E D002       972            pop AR2
0A50 209554     972           jb SHARED_PIN, checkTempInc
0A53            972   
0A53            972           ; Set the LCD data pins to logic 1
0A53 D293       972           setb START_PIN
0A55 D281       972           setb CHANGE_MENU_PIN
0A57 D282       972           setb INC_TEMP_PIN
0A59 D283       972           setb INC_TIME_PIN
0A5B D280       972           setb STOP_PIN
0A5D            972   
0A5D            972           ; check push buttons 1 by one
0A5D C293       972           clr START_PIN
0A5F A295       972           mov c, SHARED_PIN
0A61 9204       972           mov PB_START_PIN, c
0A63 D293       972           setb START_PIN
0A65            972   
0A65 C281       972           clr CHANGE_MENU_PIN
0A67 A295       972           mov c, SHARED_PIN
0A69 9205       972           mov PB_CHANGE_MENU_PIN, c
0A6B D281       972           setb CHANGE_MENU_PIN
0A6D            972   
0A6D C282       972           clr INC_TEMP_PIN
0A6F A295       972           mov c, SHARED_PIN
0A71 9206       972           mov PB_INC_TEMP_PIN, c
0A73 D282       972           setb INC_TEMP_PIN
0A75            972   
0A75 C283       972           clr INC_TIME_PIN
0A77 A295       972           mov c, SHARED_PIN
0A79 9207       972           mov PB_INC_TIME_PIN, c
0A7B D283       972           setb INC_TIME_PIN
0A7D            972   
0A7D C280       972           clr STOP_PIN
0A7F A295       972           mov c, SHARED_PIN
0A81 9208       972           mov PB_STOP_PIN, c
0A83 D280       972           setb STOP_PIN
0A85            972   
0A85 20071F     972           jb PB_INC_TIME_PIN, checkTempInc ; check that the variable flag is not 1, otherwise jmp
0A88            972   
0A88            972   
0A88 B4000F     973                   cjne a, #MENU_STATE_SOAK, incTimeReflow
0A8B E547       974                           mov     a, time_soak 
0A8D 2405       975                           add     A, #5        
0A8F F547       976                           mov     time_soak, a 
0A91            977   
0A91            978                           ; check if time_soak will need to reset - assumes multiples of 5
0A91            979                           ; +5 to constants so they display on LCD b/f reseting
0A91 B45F13     980                           cjne a, #(MAX_TIME+5), checkTempInc 
0A94 7405       981                           mov a, #MIN_TIME
0A96 F547       982                           mov time_soak, a
0A98            983   
0A98 800D       984                           sjmp checkTempInc       
0A9A            985                   incTimeReflow:
0A9A E549       986                           mov     a, time_refl
0A9C 2405       987                           add     A, #5
0A9E F549       988                           mov     time_refl, a
0AA0            989   
0AA0 B45F04     990                           cjne a, #(MAX_TIME+5), checkTempInc
0AA3 7405       991                           mov a, #MIN_TIME
0AA5 F549       992                           mov time_refl, a
0AA7            993   
0AA7            994   
0AA7            995           checkTempInc:
0AA7 D204       996           setb PB_START_PIN
0AA9 D205       996           setb PB_CHANGE_MENU_PIN
0AAB D206       996           setb PB_INC_TEMP_PIN
0AAD D207       996           setb PB_INC_TIME_PIN
0AAF D208       996           setb PB_STOP_PIN
0AB1            996           
0AB1 D295       996           setb SHARED_PIN
0AB3            996           ; check if any push buttons are pressed
0AB3 C293       996           clr START_PIN             
0AB5 C281       996           clr CHANGE_MENU_PIN       
0AB7 C282       996           clr INC_TEMP_PIN          
0AB9 C283       996           clr INC_TIME_PIN          
0ABB C280       996           clr STOP_PIN
0ABD            996   
0ABD            996           ; debounce
0ABD 209560     996           jb SHARED_PIN, enterMenuStateCheck ; use helper label to jump to the end
0AC0 C002       996            push AR2
0AC2 7A32       996            mov R2, #50
0AC4 120038     996            lcall ?Wait_Milli_Seconds
0AC7 D002       996            pop AR2
0AC9 209554     996           jb SHARED_PIN, enterMenuStateCheck
0ACC            996   
0ACC            996           ; Set the LCD data pins to logic 1
0ACC D293       996           setb START_PIN
0ACE D281       996           setb CHANGE_MENU_PIN
0AD0 D282       996           setb INC_TEMP_PIN
0AD2 D283       996           setb INC_TIME_PIN
0AD4 D280       996           setb STOP_PIN
0AD6            996   
0AD6            996           ; check push buttons 1 by one
0AD6 C293       996           clr START_PIN
0AD8 A295       996           mov c, SHARED_PIN
0ADA 9204       996           mov PB_START_PIN, c
0ADC D293       996           setb START_PIN
0ADE            996   
0ADE C281       996           clr CHANGE_MENU_PIN
0AE0 A295       996           mov c, SHARED_PIN
0AE2 9205       996           mov PB_CHANGE_MENU_PIN, c
0AE4 D281       996           setb CHANGE_MENU_PIN
0AE6            996   
0AE6 C282       996           clr INC_TEMP_PIN
0AE8 A295       996           mov c, SHARED_PIN
0AEA 9206       996           mov PB_INC_TEMP_PIN, c
0AEC D282       996           setb INC_TEMP_PIN
0AEE            996   
0AEE C283       996           clr INC_TIME_PIN
0AF0 A295       996           mov c, SHARED_PIN
0AF2 9207       996           mov PB_INC_TIME_PIN, c
0AF4 D283       996           setb INC_TIME_PIN
0AF6            996   
0AF6 C280       996           clr STOP_PIN
0AF8 A295       996           mov c, SHARED_PIN
0AFA 9208       996           mov PB_STOP_PIN, c
0AFC D280       996           setb STOP_PIN
0AFE            996   
0AFE 20061F     996           jb PB_INC_TEMP_PIN, enterMenuStateCheck ; check that the variable flag is not 1, otherwise jmp
0B01            996   
0B01 B4000F     997                   cjne a, #MENU_STATE_SOAK, incTempReflow
0B04 E546       998                           mov     a, temp_soak 
0B06 2405       999                           add     A, #5        
0B08 F546      1000                           mov     temp_soak, a 
0B0A           1001   
0B0A B4FF13    1002                           cjne a, #(MAX_TEMP+5), enterMenuStateCheck
0B0D 7464      1003                           mov a, #MIN_TEMP
0B0F F546      1004                           mov temp_soak, a
0B11           1005   
0B11 800D      1006                           sjmp enterMenuStateCheck       
0B13           1007                   incTempReflow:
0B13 E548      1008                           mov     a, temp_refl
0B15 2405      1009                           add     A, #5
0B17 F548      1010                           mov     temp_refl, a
0B19           1011   
0B19 B4FF04    1012                           cjne a, #(MAX_TEMP+5), enterMenuStateCheck
0B1C 7464      1013                           mov a, #MIN_TEMP
0B1E F548      1014                           mov temp_refl, a
0B20           1015   
0B20           1016           ; ---------------- FSM State Check ---------------- ;  
0B20           1017           enterMenuStateCheck:
0B20 D282      1018                   setb INC_TEMP_PIN
0B22 E545      1019                   mov     a, MENU_STATE
0B24           1020   
0B24           1021           menuFSM_configSoak:
0B24 B40069    1022                   cjne    a, #MENU_STATE_SOAK, menuFSM_configReflow
0B27           1023                   ; display Soak Menu Options
0B27 C0E0      1024            push acc
0B29 7401      1024            mov a, #1
0B2B 14        1024            dec a
0B2C 1200C7    1024            lcall ?Set_Cursor_1 ; Select column and row
0B2F D0E0      1024            pop acc
0B31 C083      1025            push dph
0B33 C082      1025            push dpl
0B35 C0E0      1025            push acc
0B37 90037D    1025            mov dptr, #LCD_soakTemp
0B3A 1200BA    1025            lcall ?Send_Constant_String
0B3D D0E0      1025            pop acc
0B3F D082      1025            pop dpl
0B41 D083      1025            pop dph
0B43           1025   
0B43 E546      1026                   mov     a, temp_soak
0B45 120427    1027                   lcall   SendToLCD
0B48 C083      1028            push dph
0B4A C082      1028            push dpl
0B4C C0E0      1028            push acc
0B4E 9003AF    1028            mov dptr, #LCD_clearLine
0B51 1200BA    1028            lcall ?Send_Constant_String
0B54 D0E0      1028            pop acc
0B56 D082      1028            pop dpl
0B58 D083      1028            pop dph
0B5A C0E0      1029            push acc
0B5C 7401      1029            mov a, #1
0B5E 14        1029            dec a
0B5F 1200C5    1029            lcall ?Set_Cursor_2 ; Select column and row
0B62 D0E0      1029            pop acc
0B64 C083      1030            push dph
0B66 C082      1030            push dpl
0B68 C0E0      1030            push acc
0B6A 900371    1030            mov dptr, #LCD_soakTime
0B6D 1200BA    1030            lcall ?Send_Constant_String
0B70 D0E0      1030            pop acc
0B72 D082      1030            pop dpl
0B74 D083      1030            pop dph
0B76 E547      1031                   mov     a, time_soak
0B78 120427    1032                   lcall   SendToLCD
0B7B C083      1033            push dph
0B7D C082      1033            push dpl
0B7F C0E0      1033            push acc
0B81 9003AF    1033            mov dptr, #LCD_clearLine
0B84 1200BA    1033            lcall ?Send_Constant_String
0B87 D0E0      1033            pop acc
0B89 D082      1033            pop dpl
0B8B D083      1033            pop dph
0B8D 020C02    1034                   ljmp    menu_FSM_done
0B90           1035   
0B90           1036           menuFSM_configReflow:
0B90 B40169    1037                   cjne    a, #MENU_STATE_REFLOW, reset_menu_state
0B93           1038                   ; display Reflow Menu Options
0B93 C0E0      1039            push acc
0B95 7401      1039            mov a, #1
0B97 14        1039            dec a
0B98 1200C7    1039            lcall ?Set_Cursor_1 ; Select column and row
0B9B D0E0      1039            pop acc
0B9D C083      1040            push dph
0B9F C082      1040            push dpl
0BA1 C0E0      1040            push acc
0BA3 900395    1040            mov dptr, #LCD_reflowTemp
0BA6 1200BA    1040            lcall ?Send_Constant_String
0BA9 D0E0      1040            pop acc
0BAB D082      1040            pop dpl
0BAD D083      1040            pop dph
0BAF E548      1041                   mov     a, temp_refl
0BB1 120427    1042                   lcall   SendToLCD
0BB4 C083      1043            push dph
0BB6 C082      1043            push dpl
0BB8 C0E0      1043            push acc
0BBA 9003AF    1043            mov dptr, #LCD_clearLine
0BBD 1200BA    1043            lcall ?Send_Constant_String
0BC0 D0E0      1043            pop acc
0BC2 D082      1043            pop dpl
0BC4 D083      1043            pop dph
0BC6 C0E0      1044            push acc
0BC8 7401      1044            mov a, #1
0BCA 14        1044            dec a
0BCB 1200C5    1044            lcall ?Set_Cursor_2 ; Select column and row
0BCE D0E0      1044            pop acc
0BD0 C083      1045            push dph
0BD2 C082      1045            push dpl
0BD4 C0E0      1045            push acc
0BD6 900389    1045            mov dptr, #LCD_reflowTime
0BD9 1200BA    1045            lcall ?Send_Constant_String
0BDC D0E0      1045            pop acc
0BDE D082      1045            pop dpl
0BE0 D083      1045            pop dph
0BE2 E549      1046                   mov     a, time_refl
0BE4 120427    1047                   lcall   SendToLCD
0BE7 C083      1048            push dph
0BE9 C082      1048            push dpl
0BEB C0E0      1048            push acc
0BED 9003AF    1048            mov dptr, #LCD_clearLine
0BF0 1200BA    1048            lcall ?Send_Constant_String
0BF3 D0E0      1048            pop acc
0BF5 D082      1048            pop dpl
0BF7 D083      1048            pop dph
0BF9 020C02    1049                   ljmp    menu_FSM_done
0BFC           1050   
0BFC           1051           reset_menu_state: ; sets menu state variable to 0
0BFC 754500    1052                   mov     MENU_STATE, #MENU_STATE_SOAK
0BFF 020C02    1053                   ljmp    menu_FSM_done
0C02           1054   
0C02           1055           menu_FSM_done:
0C02 22        1056                   ret
0C03           1057   
0C03           1058   main_program:
0C03           1059           ; George
0C03 75817F    1060           mov     sp, #0x7f
0C06 120652    1061           lcall   Initilize_All
0C09 120087    1062           lcall   LCD_4BIT
0C0C           1063           ; lcall   configure_LCD_multiplexing
0C0C           1064   
0C0C           1065           ; Default display - 
0C0C           1066           ; Reflow oven controller 
0C0C           1067           ; (Start or Configure?)
0C0C           1068           PROGRAM_ENTRY:
0C0C C0E0      1069            push acc
0C0E 7401      1069            mov a, #1
0C10 14        1069            dec a
0C11 1200C7    1069            lcall ?Set_Cursor_1 ; Select column and row
0C14 D0E0      1069            pop acc
0C16 C083      1070            push dph
0C18 C082      1070            push dpl
0C1A C0E0      1070            push acc
0C1C 900352    1070            mov dptr, #LCD_defaultTop
0C1F 1200BA    1070            lcall ?Send_Constant_String
0C22 D0E0      1070            pop acc
0C24 D082      1070            pop dpl
0C26 D083      1070            pop dph
0C28 C0E0      1071            push acc
0C2A 7401      1071            mov a, #1
0C2C 14        1071            dec a
0C2D 1200C5    1071            lcall ?Set_Cursor_2 ; Select column and row
0C30 D0E0      1071            pop acc
0C32 C083      1072            push dph
0C34 C082      1072            push dpl
0C36 C0E0      1072            push acc
0C38 900360    1072            mov dptr, #LCD_defaultBot
0C3B 1200BA    1072            lcall ?Send_Constant_String
0C3E D0E0      1072            pop acc
0C40 D082      1072            pop dpl
0C42 D083      1072            pop dph
0C44           1073   
0C44           1074           checkStartButton: ; assumed negative logic - used a label for an easy ljmp in the future
0C44 D204      1075           setb PB_START_PIN
0C46 D205      1075           setb PB_CHANGE_MENU_PIN
0C48 D206      1075           setb PB_INC_TEMP_PIN
0C4A D207      1075           setb PB_INC_TIME_PIN
0C4C D208      1075           setb PB_STOP_PIN
0C4E           1075           
0C4E D295      1075           setb SHARED_PIN
0C50           1075           ; check if any push buttons are pressed
0C50 C293      1075           clr START_PIN             
0C52 C281      1075           clr CHANGE_MENU_PIN       
0C54 C282      1075           clr INC_TEMP_PIN          
0C56 C283      1075           clr INC_TIME_PIN          
0C58 C280      1075           clr STOP_PIN
0C5A           1075   
0C5A           1075           ; debounce
0C5A 209544    1075           jb SHARED_PIN, noStartButtonPress ; use helper label to jump to the end
0C5D C002      1075            push AR2
0C5F 7A32      1075            mov R2, #50
0C61 120038    1075            lcall ?Wait_Milli_Seconds
0C64 D002      1075            pop AR2
0C66 209538    1075           jb SHARED_PIN, noStartButtonPress
0C69           1075   
0C69           1075           ; Set the LCD data pins to logic 1
0C69 D293      1075           setb START_PIN
0C6B D281      1075           setb CHANGE_MENU_PIN
0C6D D282      1075           setb INC_TEMP_PIN
0C6F D283      1075           setb INC_TIME_PIN
0C71 D280      1075           setb STOP_PIN
0C73           1075   
0C73           1075           ; check push buttons 1 by one
0C73 C293      1075           clr START_PIN
0C75 A295      1075           mov c, SHARED_PIN
0C77 9204      1075           mov PB_START_PIN, c
0C79 D293      1075           setb START_PIN
0C7B           1075   
0C7B C281      1075           clr CHANGE_MENU_PIN
0C7D A295      1075           mov c, SHARED_PIN
0C7F 9205      1075           mov PB_CHANGE_MENU_PIN, c
0C81 D281      1075           setb CHANGE_MENU_PIN
0C83           1075   
0C83 C282      1075           clr INC_TEMP_PIN
0C85 A295      1075           mov c, SHARED_PIN
0C87 9206      1075           mov PB_INC_TEMP_PIN, c
0C89 D282      1075           setb INC_TEMP_PIN
0C8B           1075   
0C8B C283      1075           clr INC_TIME_PIN
0C8D A295      1075           mov c, SHARED_PIN
0C8F 9207      1075           mov PB_INC_TIME_PIN, c
0C91 D283      1075           setb INC_TIME_PIN
0C93           1075   
0C93 C280      1075           clr STOP_PIN
0C95 A295      1075           mov c, SHARED_PIN
0C97 9208      1075           mov PB_STOP_PIN, c
0C99 D280      1075           setb STOP_PIN
0C9B           1075   
0C9B 200403    1075           jb PB_START_PIN, noStartButtonPress ; check that the variable flag is not 1, otherwise jmp
0C9E           1075   
0C9E 020D0E    1076                   ljmp    enter_oven_fsm ; successful button press, enter oven FSM   
0CA1           1077   
0CA1           1078           noStartButtonPress:
0CA1 D293      1079                   setb    START_PIN
0CA3           1080                   ; if the 'IN_MENU' flag is set, always enter into the menu FSM, this is so that the menu FSM can always be entered
0CA3           1081                   ; creates an infinite loop that will always display menu once entered - broken if START button pressed
0CA3 300106    1082                   jnb     IN_MENU_FLAG, checkMenuButtonPress
0CA6 1209CD    1083                   lcall   MENU_FSM 
0CA9 020C44    1084                   ljmp    checkStartButton
0CAC           1085   
0CAC           1086           checkMenuButtonPress:
0CAC           1087                   ; check for enter menu button press (reusing increment menu pin)
0CAC D204      1088           setb PB_START_PIN
0CAE D205      1088           setb PB_CHANGE_MENU_PIN
0CB0 D206      1088           setb PB_INC_TEMP_PIN
0CB2 D207      1088           setb PB_INC_TIME_PIN
0CB4 D208      1088           setb PB_STOP_PIN
0CB6           1088           
0CB6 D295      1088           setb SHARED_PIN
0CB8           1088           ; check if any push buttons are pressed
0CB8 C293      1088           clr START_PIN             
0CBA C281      1088           clr CHANGE_MENU_PIN       
0CBC C282      1088           clr INC_TEMP_PIN          
0CBE C283      1088           clr INC_TIME_PIN          
0CC0 C280      1088           clr STOP_PIN
0CC2           1088   
0CC2           1088           ; debounce
0CC2 209544    1088           jb SHARED_PIN, noMenuButtonPress ; use helper label to jump to the end
0CC5 C002      1088            push AR2
0CC7 7A32      1088            mov R2, #50
0CC9 120038    1088            lcall ?Wait_Milli_Seconds
0CCC D002      1088            pop AR2
0CCE 209538    1088           jb SHARED_PIN, noMenuButtonPress
0CD1           1088   
0CD1           1088           ; Set the LCD data pins to logic 1
0CD1 D293      1088           setb START_PIN
0CD3 D281      1088           setb CHANGE_MENU_PIN
0CD5 D282      1088           setb INC_TEMP_PIN
0CD7 D283      1088           setb INC_TIME_PIN
0CD9 D280      1088           setb STOP_PIN
0CDB           1088   
0CDB           1088           ; check push buttons 1 by one
0CDB C293      1088           clr START_PIN
0CDD A295      1088           mov c, SHARED_PIN
0CDF 9204      1088           mov PB_START_PIN, c
0CE1 D293      1088           setb START_PIN
0CE3           1088   
0CE3 C281      1088           clr CHANGE_MENU_PIN
0CE5 A295      1088           mov c, SHARED_PIN
0CE7 9205      1088           mov PB_CHANGE_MENU_PIN, c
0CE9 D281      1088           setb CHANGE_MENU_PIN
0CEB           1088   
0CEB C282      1088           clr INC_TEMP_PIN
0CED A295      1088           mov c, SHARED_PIN
0CEF 9206      1088           mov PB_INC_TEMP_PIN, c
0CF1 D282      1088           setb INC_TEMP_PIN
0CF3           1088   
0CF3 C283      1088           clr INC_TIME_PIN
0CF5 A295      1088           mov c, SHARED_PIN
0CF7 9207      1088           mov PB_INC_TIME_PIN, c
0CF9 D283      1088           setb INC_TIME_PIN
0CFB           1088   
0CFB C280      1088           clr STOP_PIN
0CFD A295      1088           mov c, SHARED_PIN
0CFF 9208      1088           mov PB_STOP_PIN, c
0D01 D280      1088           setb STOP_PIN
0D03           1088   
0D03 200503    1088           jb PB_CHANGE_MENU_PIN, noMenuButtonPress ; check that the variable flag is not 1, otherwise jmp
0D06           1088   
0D06           1088   
0D06           1089                   ; setb IN_MENU_FLAG; successful button press, enter menu FSM loop ; - THIS LINE CAUSES THE BUG
0D06 020D53    1090                   ljmp    setMenuFlag
0D09           1091                   
0D09           1092           noMenuButtonPress:
0D09 D281      1093                   setb CHANGE_MENU_PIN
0D0B 020C44    1094                   ljmp    checkStartButton ; this line does not execute if ljmp setMenuFlag is there?!?!?
0D0E           1095   
0D0E           1096           enter_oven_fsm:
0D0E C201      1097                   clr     IN_MENU_FLAG ; No longer in menu
0D10 D202      1098                   setb    IN_OVEN_FLAG
0D12 C0E0      1099            push acc
0D14 7401      1099            mov a, #1
0D16 14        1099            dec a
0D17 1200C7    1099            lcall ?Set_Cursor_1 ; Select column and row
0D1A D0E0      1099            pop acc
0D1C C083      1100            push dph
0D1E C082      1100            push dpl
0D20 C0E0      1100            push acc
0D22 9003AF    1100            mov dptr, #LCD_clearLine
0D25 1200BA    1100            lcall ?Send_Constant_String
0D28 D0E0      1100            pop acc
0D2A D082      1100            pop dpl
0D2C D083      1100            pop dph
0D2E C0E0      1101            push acc
0D30 7401      1101            mov a, #1
0D32 14        1101            dec a
0D33 1200C5    1101            lcall ?Set_Cursor_2 ; Select column and row
0D36 D0E0      1101            pop acc
0D38 C083      1102            push dph
0D3A C082      1102            push dpl
0D3C C0E0      1102            push acc
0D3E 9003AF    1102            mov dptr, #LCD_clearLine
0D41 1200BA    1102            lcall ?Send_Constant_String
0D44 D0E0      1102            pop acc
0D46 D082      1102            pop dpl
0D48 D083      1102            pop dph
0D4A           1103   
0D4A 120475    1104                   lcall   Timer2_Init  ; breaks things
0D4D 1206F9    1105                   lcall   OVEN_FSM     ; will call STOP_PROCESS which loops back to the entry point
0D50 1206D9    1106                   lcall   STOP_PROCESS ; added for safety
0D53           1107                   
0D53           1108           setMenuFlag: 
0D53 D201      1109                   setb    IN_MENU_FLAG
0D55 020C44    1110                   ljmp    checkStartButton
0D58           1111   
0D58           1112           program_end:
0D58 020C03    1113                   ljmp    main_program
0D5B           1114   EN
