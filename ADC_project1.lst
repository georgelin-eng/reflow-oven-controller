0000              1   ; 76E003 ADC test program: Reads channel 7 on P1.1, pin 14
0000              2   ; This version uses an LED as voltage reference connected to pin 6 (P1.7/AIN0)
0000              3   
                  5   $LIST
0000              7   
0000              8   ;  N76E003 pinout:
0000              9   ;                               -------
0000             10   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             11   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             12   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             13   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             14   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             15   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             16   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             17   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             18   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             19   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             20   ;                               -------
0000             21   ;
0000             22   
0000             23   CLK               EQU 16600000 ; Microcontroller system frequency in Hz
0000             24   BAUD              EQU 115200 ; Baud rate of UART in bps
0000             25   TIMER1_RELOAD     EQU (0x100-(CLK/(16*BAUD)))
0000             26   TIMER0_RELOAD_1MS EQU (0x10000-(CLK/1000))
0000             27   
0000             28   ORG 0x0000
0000 0204A1      29            ljmp main
0003             30   
0003             31   ;                     1234567890123456    <- This helps determine the location of the counter
0003 2A2A2A20    32   test_message:     db '*** ADC TEST ***', 0
     41444320
     54455354
     202A2A2A
     00
0014 56287069    33   value_message:    db 'V(pin 14)=      ', 0
     6E203134
     293D2020
     20202020
     00
0025             34   cseg
0025             35   ; These 'equ' must match the hardware wiring
0025             36   LCD_RS equ P1.3
0025             37   LCD_E  equ P1.4
0025             38   LCD_D4 equ P0.0
0025             39   LCD_D5 equ P0.1
0025             40   LCD_D6 equ P0.2
0025             41   LCD_D7 equ P0.3
0025             42   
                 44   	$LIST
00D9             46   
00D9             47   ; These register definitions needed by 'math32.inc'
0030             48   DSEG at 30H
0030             49   x:   ds 4
0034             50   y:   ds 4
0038             51   bcd: ds 5
003D             52   VLED_ADC: ds 2
003F             53   
0000             54   BSEG
0000             55   mf: dbit 1
0001             56   
                547   $LIST
                 58   $LIST
0349             60   
0349             61   
0349             62   Init_All:
0349             63            ; Configure all the pins for biderectional I/O
0349 75AC00      64            mov     P3M1, #0x00
034C 75AD00      65            mov     P3M2, #0x00
034F 75B300      66            mov     P1M1, #0x00
0352 75B400      67            mov     P1M2, #0x00
0355 75B100      68            mov     P0M1, #0x00
0358 75B200      69            mov     P0M2, #0x00
035B             70            
035B 438E10      71            orl     CKCON, #0x10 ; CLK is the input for timer 1
035E 438780      72            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
0361 759852      73            mov     SCON, #0x52
0364 53C4DF      74            anl     T3CON, #0b11011111
0367 53890F      75            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
036A 438920      76            orl     TMOD, #0x20 ; Timer 1 Mode 2
036D 758DF7      77            mov     TH1, #TIMER1_RELOAD ; TH1=TIMER1_RELOAD;
0370 D28E        78            setb TR1
0372             79            
0372             80            ; Using timer 0 for delay functions.  Initialize here:
0372 C28C        81            clr     TR0 ; Stop timer 0
0374 438E08      82            orl     CKCON,#0x08 ; CLK is the input for timer 0
0377 5389F0      83            anl     TMOD,#0xF0 ; Clear the configuration bits for timer 0
037A 438901      84            orl     TMOD,#0x01 ; Timer 0 in Mode 1: 16-bit timer
037D             85            
037D             86            ; Initialize the pins used by the ADC (P1.1, P1.7) as input.
037D 43B382      87            orl     P1M1, #0b10000010
0380 53B47D      88            anl     P1M2, #0b01111101
0383             89            
0383             90            ; Initialize and start the ADC:
0383 53E8F0      91            anl ADCCON0, #0xF0
0386 43E807      92            orl ADCCON0, #0x07 ; Select channel 7
0389             93            ; AINDIDS select if some pins are analog inputs or digital I/O:
0389 75F600      94            mov AINDIDS, #0x00 ; Disable all analog inputs
038C 43F681      95            orl AINDIDS, #0b10000001 ; Activate AIN0 and AIN7 analog inputs
038F 43E101      96            orl ADCCON1, #0x01 ; Enable ADC
0392             97            
0392 22          98            ret
0393             99            
0393            100   InitSerialPort:
0393            101            
0393            102       ; Since the reset button bounces, we need to wait a bit before
0393            103       ; sending messages, otherwise we risk displaying gibberish!
0393 79C8       104       mov R1, #200
0395 7868       105       mov R0, #104
0397 D8FE       106       djnz R0, $   ; 4 cycles->4*60.285ns*104=25us
0399 D9FA       107       djnz R1, $-4 ; 25us*200=5.0ms
039B            108   
039B            109       ; Now we can proceed with the configuration of the serial port
039B 438E10     110            orl     CKCON, #0x10 ; CLK is the input for timer 1
039E 438780     111            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
03A1 759852     112            mov     SCON, #0x52
03A4 53C4DF     113            anl     T3CON, #0b11011111
03A7 53890F     114            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
03AA 438920     115            orl     TMOD, #0x20 ; Timer 1 Mode 2
03AD 758DF7     116            mov     TH1, #TIMER1_RELOAD
03B0 D28E       117            setb TR1
03B2 22         118       ret
03B3            119   
03B3            120   ; Send a character using the serial port
03B3            121   putchar:
03B3 3099FD     122       jnb TI, putchar
03B6 C299       123       clr TI
03B8 F599       124       mov SBUF, a
03BA 22         125       ret
03BB            126   
03BB            127   ;send a BCD num to PuTTy
03BB            128   
                129   Send_BCD mac
                130   	push ar0
                131   	mov r0, %0
                132   	lcall ?Send_BCD
                133   	pop ar0
                134   	endmac
03BB            135            
03BB            136   ?Send_BCD:
03BB C0E0       137            push acc
03BD            138            ;write most significant digit
03BD E8         139            mov a, r0
03BE C4         140            swap a
03BF 540F       141            anl a, #0fh
03C1 4430       142            orl a, #30h
03C3 1203B3     143            lcall putchar
03C6            144            ;write least significant digit
03C6 E8         145            mov a, r0
03C7 540F       146            anl a, #0fh
03C9 4430       147            orl a, #30h
03CB 1203B3     148            lcall putchar
03CE D0E0       149            pop acc
03D0 22         150            ret
03D1            151            
03D1            152   Send_formated_BCD:
03D1            153            
03D1 C000       154            push ar0
03D3 A83B       154            mov r0, bcd+3
03D5 1203BB     154            lcall ?Send_BCD
03D8 D000       154            pop ar0
03DA C000       155            push ar0
03DC A83A       155            mov r0, bcd+2
03DE 1203BB     155            lcall ?Send_BCD
03E1 D000       155            pop ar0
03E3 742E       156            mov a, #46
03E5 1203B3     157            lcall putchar
03E8 C000       158            push ar0
03EA A839       158            mov r0, bcd+1
03EC 1203BB     158            lcall ?Send_BCD
03EF D000       158            pop ar0
03F1 C000       159            push ar0
03F3 A838       159            mov r0, bcd+0
03F5 1203BB     159            lcall ?Send_BCD
03F8 D000       159            pop ar0
03FA 120495     160            lcall putCR_NL
03FD 22         161            ret
03FE            162   ; Send a constant-zero-terminated string using the serial port
03FE            163   SendString:
03FE E4         164       clr A
03FF 93         165       movc A, @A+DPTR
0400 6006       166       jz SendStringDone
0402 1203B3     167       lcall putchar
0405 A3         168       inc DPTR
0406 80F6       169       sjmp SendString
0408            170       
0408            171   SendStringDone:
0408 22         172       ret
0409            173    
0409            174   Hello_World:
0409 48656C6C   175       DB  'Hello, World!', '\r', '\n', 0
     6F2C2057
     6F726C64
     210D0A00
0419            176          
0419            177   wait_1ms:
0419 C28C       178            clr     TR0 ; Stop timer 0
041B C28D       179            clr     TF0 ; Clear overflow flag
041D 758CBF     180            mov     TH0, #high(TIMER0_RELOAD_1MS)
0420 758A28     181            mov     TL0,#low(TIMER0_RELOAD_1MS)
0423 D28C       182            setb TR0
0425 308DFD     183            jnb     TF0, $ ; Wait for overflow
0428 22         184            ret
0429            185   
0429            186   ; Wait the number of miliseconds in R2
0429            187   waitms:
0429 120419     188            lcall wait_1ms
042C DAFB       189            djnz R2, waitms
042E 22         190            ret
042F            191   
042F            192   ; We can display a number any way we want.  In this case with
042F            193   ; four decimal places.
042F            194   Display_formated_BCD:
042F C0E0       195            push acc
0431 7408       195            mov a, #8
0433 14         195            dec a
0434 1200BC     195            lcall ?Set_Cursor_2 ; Select column and row
0437 D0E0       195            pop acc
0439 C000       196            push ar0
043B A83B       196            mov r0, bcd+3
043D 1200C3     196            lcall ?Display_BCD
0440 D000       196            pop ar0
0442 C000       197            push ar0
0444 A83A       197            mov r0, bcd+2
0446 1200C3     197            lcall ?Display_BCD
0449 D000       197            pop ar0
044B C0E0       198            push acc
044D 742E       198            mov a, #'.'
044F 120074     198            lcall ?WriteData
0452 D0E0       198            pop acc
0454 C000       199            push ar0
0456 A839       199            mov r0, bcd+1
0458 1200C3     199            lcall ?Display_BCD
045B D000       199            pop ar0
045D C000       200            push ar0
045F A838       200            mov r0, bcd+0
0461 1200C3     200            lcall ?Display_BCD
0464 D000       200            pop ar0
0466            201            ;Set_Cursor(2, 10)
0466            202            ;Display_char(#'=')
0466 22         203            ret
0467            204            
0467            205   
0467            206   Read_ADC:
0467 C2EF       207            clr ADCF
0469 D2EE       208            setb ADCS ;  ADC start trigger signal
046B 30EFFD     209       jnb ADCF, $ ; Wait for conversion complete
046E            210       
046E            211       ; Read the ADC result and store in [R1, R0]
046E E5C2       212       mov a, ADCRL
0470 540F       213       anl a, #0x0f
0472 F8         214       mov R0, a
0473 E5C3       215       mov a, ADCRH   
0475 C4         216       swap a
0476 C0E0       217       push acc
0478 540F       218       anl a, #0x0f
047A F9         219       mov R1, a
047B D0E0       220       pop acc
047D 54F0       221       anl a, #0xf0
047F 48         222       orl a, R0
0480 F8         223       mov R0, A
0481 22         224            ret
0482            225            
0482            226   putNum:
0482 E4         227            clr a
0483 E9         228            mov a, r1
0484 75F00A     229            mov b, #10
0487 84         230            div ab
0488 2430       231            add a, #48
048A 1203B3     232            lcall putchar
048D            233            
048D E5F0       234            mov a, b
048F 2430       235            add a, #48
0491 1203B3     236            lcall putchar
0494 22         237            ret
0495            238   
0495            239   
0495            240   putCR_NL: ;function to print Carriage return and NL
0495 E4         241            clr a
0496 740D       242            mov a, #13
0498 1203B3     243            lcall putchar
049B 740A       244            mov a, #10
049D 1203B3     245            lcall putchar
04A0 22         246            ret
04A1            247            
04A1            248   main:
04A1 75817F     249            mov sp, #0x7f
04A4 120349     250            lcall Init_All
04A7 12007E     251       lcall LCD_4BIT
04AA            252       ;now inserting the serial initialization
04AA            253       
04AA 120393     254       lcall InitSerialPort
04AD 900409     255       mov DPTR, #Hello_World
04B0 1203FE     256       lcall SendString
04B3            257       
04B3            258       
04B3            259       ; initial messages in LCD
04B3 C0E0       260            push acc
04B5 7401       260            mov a, #1
04B7 14         260            dec a
04B8 1200BE     260            lcall ?Set_Cursor_1 ; Select column and row
04BB D0E0       260            pop acc
04BD            261       ;Send_Constant_String(#test_message)
04BD C0E0       262            push acc
04BF 7401       262            mov a, #1
04C1 14         262            dec a
04C2 1200BC     262            lcall ?Set_Cursor_2 ; Select column and row
04C5 D0E0       262            pop acc
04C7            263       ;Send_Constant_String(#value_message)
04C7            264       
04C7            265   Forever:
04C7            266   
04C7            267            ; Read the 2.08V LED voltage connected to AIN0 on pin 6
04C7 53E8F0     268            anl ADCCON0, #0xF0
04CA 43E800     269            orl ADCCON0, #0x00 ; Select channel 0
04CD            270   
04CD 120467     271            lcall Read_ADC
04D0            272            ; Save result for later use
04D0 883D       273            mov VLED_ADC+0, R0
04D2 893E       274            mov VLED_ADC+1, R1
04D4            275   
04D4            276            ; Read the signal connected to AIN7
04D4 53E8F0     277            anl ADCCON0, #0xF0
04D7 43E807     278            orl ADCCON0, #0x07 ; Select channel 7
04DA 120467     279            lcall Read_ADC
04DD            280       
04DD            281       ; Convert to voltage
04DD 8830       282            mov x+0, R0
04DF 8931       283            mov x+1, R1
04E1            284            ; Pad other bits with zero
04E1 753200     285            mov x+2, #0
04E4 753300     286            mov x+3, #0
04E7 7534CE     287            mov y+0, #low (20430 % 0x10000) 
04EA 75354F     287            mov y+1, #high(20430 % 0x10000) 
04ED 753600     287            mov y+2, #low (20430 / 0x10000) 
04F0 753700     287            mov y+3, #high(20430 / 0x10000)  ; The MEASURED LED voltage: 2.074V, with 4 decimal places
04F3 120253     288            lcall mul32
04F6            289            ; Retrive the ADC LED value
04F6 853D34     290            mov y+0, VLED_ADC+0
04F9 853E35     291            mov y+1, VLED_ADC+1
04FC            292            ; Pad other bits with zero
04FC 753600     293            mov y+2, #0
04FF 753700     294            mov y+3, #0
0502 1202E0     295            lcall div32
0505            296   
0505            297   
0505            298   
0505 753423     299            mov y+0, #low (803 % 0x10000) 
0508 753503     299            mov y+1, #high(803 % 0x10000) 
050B 753600     299            mov y+2, #low (803 / 0x10000) 
050E 753700     299            mov y+3, #high(803 / 0x10000) ;multiplying V pin by 80.3153
0511 120253     300            lcall mul32
0514            301            
0514 753460     302            mov y+0, #low (220000 % 0x10000) 
0517 75355B     302            mov y+1, #high(220000 % 0x10000) 
051A 753603     302            mov y+2, #low (220000 / 0x10000) 
051D 753700     302            mov y+3, #high(220000 / 0x10000)  ;adding 22, will change to ambient later
0520 12019E     303            lcall add32
0523            304            
0523            305            ; use put char to put individual characters 
0523            306            ; Convert to BCD and display
0523 1200D9     307            lcall hex2bcd
0526            308            
0526 12042F     309            lcall Display_formated_BCD
0529            310            
0529 7534A9     311            mov y+0, #low (27305 % 0x10000) 
052C 75356A     311            mov y+1, #high(27305 % 0x10000) 
052F 753600     311            mov y+2, #low (27305 / 0x10000) 
0532 753700     311            mov y+3, #high(27305 / 0x10000) 
0535 1201BF     312            lcall sub32
0538 1200D9     313            lcall hex2bcd
053B            314            
053B 1203D1     315            lcall Send_formated_BCD
053E            316                    
053E 7AFA       317            mov R2, #250
0540 120429     318            lcall waitms
0543 7AFA       319            mov R2, #250
0545 120429     320            lcall waitms
0548            321       
0548            322            
0548            323            ;  Wait 500 ms between conversions
0548 7AFA       324            mov R2, #250
054A 120429     325            lcall waitms
054D 7A0A       326            mov R2, #10
054F 120429     327            lcall waitms
0552            328            
0552 0204C7     329            ljmp Forever
0555            330   END
